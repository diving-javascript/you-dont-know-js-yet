# 1. 자바스크립트

<br>

- [1. 자바스크립트](#1-자바스크립트)
  - [1.1 책에 대하여](#11-책에-대하여)
  - [1.2 자바스크립트 이름의 유래](#12-자바스크립트-이름의-유래)
  - [1.3 명세서](#13-명세서)
    - [1.3.2 JS지만 JS가 아닌 웹 전용 문법](#132-js지만-js가-아닌-웹-전용-문법)
    - [모든 코드가 JS인것은 아닙니다.](#모든-코드가-js인것은-아닙니다)
  - [1.4 JS의 다양한 얼굴](#14-js의-다양한-얼굴)
  - [1.5 하위 호환성과 상위 호환성](#15-하위-호환성과-상위-호환성)
    - [1.5.1 간극을 줄이기 위한 노력](#151-간극을-줄이기-위한-노력)
    - [1.5.2 간극을 메우기 위한 방법 찾기](#152-간극을-메우기-위한-방법-찾기)
  - [1.6 인터프리터 이해하기](#16-인터프리터-이해하기)
      - [JS로 만든 소스 코드가 실행될 때가지 어떤 절차를 거치는 지 정리](#js로-만든-소스-코드가-실행될-때가지-어떤-절차를-거치는-지-정리)
    - [1.6.1 웹어셈브리](#161-웹어셈브리)
  - [1.7 엄격 모드](#17-엄격-모드)
  - [1.8 정리](#18-정리)

<br>

## 1.1 책에 대하여

<br>

## 1.2 자바스크립트 이름의 유래

자바스크립트라는 이름은 사실 마케팅 목적으로 사람들을 속이기 위해 고안된 이름
이 언어는 자바 개발자들에게 어필하기 위해 만들어졌고, 당시 스크립트라는 단어가 '가벼운 프로그램'이라는 뜻으로 유행했기 때문입니다.

TC39에서 지정하고 ECMA 표준 기구에 의해 공식화된 명칭으로 JS를 부르면 ECMAScript가 됩니다.
<br>

## 1.3 명세서

> TC39는 JS를 관리하는 기술 운영 위원회(Technical Steering Committee)로 JS의 공식 명세를 관리합니다.

### 1.3.2 JS지만 JS가 아닌 웹 전용 문법

사실 JS처럼 보이는 API 상당수가 실제로는 웹에서만 지원되는 API인 경우가 많습니다.

여러 브라우저를 대응하다 보면 브라우저 간 차이 때문에 JS는 너무 일관성이 없어! 라는 불평이 생기는 데 사실 이 차이는 대부분 JS 작동 방식 때문이 아닌 환경에 따른 작동 방식 때문에 발생합니다.

### 모든 코드가 JS인것은 아닙니다.

개발자 도구는 말 그대로 개발자를 위한 도구입니다.
개발자 도구는 개발자의 편의를 위해 만들어졌으므로 개발자 경험을 가장 우선순위에 둡니다.

개발자 도구가 JS의 프로그램 처리 방식을 **항상 엄격하게 준수하지 않는다는 점**과 이를 기대해서도 안 된다는 점을 지적하려고 합니다.

> 개발자 도구가 순수 JS작동 방식을 보장하지 않는다는 점을 알아보기 위해 환경별 차이 몇 가지만 간단히 살펴보겠습니다.

- 콘솔 '전역 스코프'최상위 레벨에서 var나 function으로 변수나 함수를 선언하면 실제 전역에 변수가 생기는지 여부(그리고 이 변수가 window 프로퍼티 속성을 지원하는 지, 그역은 성립하는지 여부)
- '전역 스코프' 최상위 레벨에서 let과 const 변수 여러 개를 선언했을 때 작동 방식
- 첫 번째 줄에 "use strict";를 입력한 후 엔터를 눌렀을 때, .js 파일 첫 줄에 "use strict";
  를 입력한 것처럼 해당 콘솔 세션이 엄격 모드로 작동하는지 여부와 첫 번째가 아닌 다른 줄에 "use strict";를 입력해도 해당 세션이 엄격 모드로 작동하는 지 여부
- 비엄격 모드에서 함수를 호출할 때 this의 기본 바인딩 방식과 "전역 객체"가 쓰이는경우, 실제 기대하는 전역 변수가 이 전역 객체에 있는 지 여부
- 여러 줄을 입력할 때 호이스팅의 작동방식

<br>

## 1.4 JS의 다양한 얼굴

프로그래밍 분야에서 패러다임이라는 용어는 코드를 어떻게 구조화할지에 대한 접근방식과 사고방식을 의미합니다.
세상에는 다양한 프로그래밍 패러다임이 있고, 한 패러다임 안에는 스타일과 형식에 차이를 둔 변형이 무수히 존재합니다.

익히 알려진 프로그래밍 패러다임으로는 절차적, 객체 지향, 함수형이 있다.

- 절차적 프로그래밍 패러다임에서는 코드가 톱다운이면서 선형적으로 구조화되는데, 이때 프로시저라 불리는 코드 단위에 미리 정해진 일련의 연산을 작성합니다.
- 객체 지향 프로그래밍 패러다임에서는 클래스 기준으로 코드를 구조화하며, 클래스에는 로직과 데이터가 정의
- 함수형 프로그래밍 패러다임에서는 코드를 함수 단위로 구조화합니다. 이때 함수는 (절차적 프로그래밍의 함수와는 달리)부수 효과가 없는 순수 함수입니다.

패러다임에는 옮고 그름이 없습니다. 패러다임은 개발자가 문제와 해결책에 접근하는 방법과 코드를 구성하고 유지 보수하는 방법을 안내하는 표지판 같은 역활을 할 뿐입니다.

JS는 다중 패러다임 언어라 절차적,객체 지향, 함수형 스타일 코드를 모두 작성 할 수 있습니다.

<br>

## 1.5 하위 호환성과 상위 호환성

JS를 지탱하는 기본 원칙 중 하나는 **하위 호환성 보장** 보장

> 하위 호환성 이란
> 이전 버전에서 새로운 버전 기능을 사용 가능한 것
> 단 한번이라도 유효한 JS 문법이라고 인정되면 명세서가 변경되더라도 절대 그 유효성이 깨지지 않는다는 의미

하위 호환성 덕분에 1995년 작성한 코드가 시간이 흘러도 무조건 작동한다는 걸 보장받습니다.

다만 언제나 예외는 있습니다.
TC39에서 하위 호환성을 깨는 결정을 하기도 함

하위 호환성과 대응되는 개념으로는 **상위 호환성**이 있습니다.

> 상위 호환성 이란
> 새로운 버전의 소프트웨어나 시스템이 이전 버전과의 호환성을 유지하는 성질을 말합니다. 즉, 새로운 버전에서도 이전 버전에서 만들어진 데이터, 프로그램, 하드웨어 등이 제대로 작동하도록 설계된 것을 의미합니다.
> 새로운 버전에서 하위 버전 기능을 사용 할 수 있는 것
> 만약 JS가 상위 호환성을 준수하는 언어였다면, 새로운 명세서에 추가된 문법으로 코드르 작성했을 때 이전 명세서를 준수하는 구형 JS엔진에서 문제가 발생하지 않아야 합니다.

하지만 JS 상위 호환성을 보장 하지 않습니다.

HTML과 CSS는 상위 호환성을 보장하지만 하위 호환성을 보장하지는 않습니다.
1995년에 작성된 HTML과 CSS 코드를 오늘 날에 작동하지 않을 수 있습니다.(작동할 수도 있음)
그런데 특이하게 2010년에 만들어진 브라우저에서 2019년에 추가된 기능을 사용할 때 웹 페이지가"망가지지는" 않습니다. 브라우저는 인식이 불가능한 HTML/CSS는 건너뛰고 인식 가능한 HTML/CSS는 명세서에 따라 처리하기 때문입니다.
<br>

### 1.5.1 간극을 줄이기 위한 노력

구 엔진과 호환되지 않는 문법은 트랜스파일을 통해 호환성 문제를 해결할 수 있습니다.

> 트랜스 파일이란
>
> JS 커뮤니티에서 만든 용어로, 한 형태에서 다른 형태로 소스 코드를 변환해주는 것을 의미합니다.
> 이때 변환 후 산출물은 소스 코드립니다.
> 상위 호환성으로 인해 발생하는 문제 대부분은 트랜스파일러를 사용하면 해결됩니다.
> 트랜스파일러는 새로운 JS문법을 오래된 문법으로 바궞며 주로 바벨을 사용합니다.

### 1.5.2 간극을 메우기 위한 방법 찾기

상위 호환성 문제가 새로운 문법이 아닌 근래에 추가되었지만, 아직 지원하지 않는 api메서드 때문에 발생했다면, 메서드 정의를 추가해 이미 이 메서드가 오래된 한경에도 있었던 것 처럼 해주는 방법이 가장 일반적인 해결책입니다.

이런 패턴을 폴리필(일명 심 shim)이라고 합니다.
예시 ES2019를 지원하지 않는 환경에서 실행하면 finally()가 존재하지 않으므로 오류가 발생
finally 폴리필 예시

```
if(!Promise.prototype.finally) {
  Promise.prototype.finally =function f(fn){
    return thie.then(
      function t(v){
        return Promise.resolve(fun())
        .then(function t()){
          return v;
        }
      },
      funciton c(e){
        return Promise.resolve(fn()).then(function t()){
          throw e;
        }
      }
    )
  }
}
```

트랜스파일이나 폴리필은 오래된 환경이나 애플리케이션,JS 최신 기능 이 둘 사이의 간극을 메꾸는 가교역할을 합니다.

## 1.6 인터프리터 이해하기

프로그래밍 언어 발전사에서 인터프리터 언어와 스크립트 언어는 컴파일 언어에 비해 열악하다고 평가 받아옴
성능 최적화가 잘 안된다는 인식과 더불어 일부 스크립트 언어에서 좀 더 성숙한 방식인 동적 타입 대신 정적 타입을 사용하는 등의 이유 때문입니다.

컴파일을 거치면 보통 분산 시스템에서 언제든 배포할 수 있는 바이너리 파일이 생성됩니다.
그런데 JS는 소스 코드 자체를 배포하지, 바이너리 파일을 배포하는 게 아니기 때문에 많은 사람이 JS는 컴파일러 언어가 아니고 주장합니다. 인터프리터 언어인지 컴파일러 언어인지에 따라 배포방식이 달라지는 데, 오늘날에는 배포방식이 더 이상 중요하지 않다고 주장하는 이들이 늘고있다.

이런 잘못된 정보에 기반한 주장은 무시해야 합니다. JS가 인터프리터 언어인지 컴파일 언어인지 명확히 이해하고 있어야 JS가 오류를 어떻게 처리하는지를 알 수 있기 때문입니다.

스크립트 언어나 인터프리터 언어는 대개 위에서 아래로 한 줄씩 코드가 실행되는 방식으로 만들어집니다.
인터프리터나 스크립트 언어로 작성한 프로그램의 다섯 번째 줄에 오류가 있다면 네 번째 줄이 실행되기 전까지는 오류를 발견하지 못합니다.

한편 프로그램이 실행되기 전에 **파싱**이라 부르는 사전 단계를 거치는 언어도 있습니다.
파싱과 컴파일을 거치는 언어의 다섯 번째 줄에 유효하지 않은 명령이 있다면 파싱 단계에서 오류가 발견되므로 사전에 오류를 차단할 수 있습니다.
굳이 실행까지 하지 않아도 파싱이 되지 않아 프로글매을 실행할 수 없기 때문입니다.

'파싱'을 거치는 언어와 '컴파일'을 거치 언어에는 어떤 공통점이 있을까요 ?

- 모든 컴파일 언어가 파싱을 거친다는 점입니다.
  파싱이 완전히 끝난 다음에는 파싱 결과인 추상 구문 트리(AST)를 컴퓨터가 실행할 수 있는 형태로 바꿔주는 작업이 이어집니다. 파싱을 거치는 언어는 파싱에 끝나는 게 아니라 실행 가능한 코드를 생성하는 작업까지 수행합니다. 이런 이유로 파싱을 거치는 언어는 컴파일 언어라고 통용되는 것

> 추상 구문 트리란 ?
> 추상 구문 트리(Abstract Syntax Tree, AST)는 컴퓨터 프로그래밍에서 소스 코드의 구조를 나타내는 트리(tree) 구조입니다. 프로그래밍 언어의 문법에 따라 구성된 소스 코드를 분석하고, 그 구조를 단순화시켜 표현한 것이죠. AST는 컴파일러나 인터프리터 같은 언어 프로세서가 소스 코드를 분석하고 변환하는 과정에서 중요한 역할을 합니다.

> 컴파일 언어란?
> 컴파일 언어는 고급 프로그래밍 언어로 작성된 코드를 사람이 읽을 수 있는 형태에서 기계가 실행할 수 있는 기계어(또는 중간 언어)로 변환하는 과정을 거치는 프로그래밍 언어를 말합니다. 이 변환 과정을 수행하는 프로그램을 컴파일러라고 하며, 컴파일러는 소스 코드를 한 번에 전체적으로 분석하고 실행 파일을 생성합니다.

JS로 작성한 소스 코드는 실행 전에 파싱을 거칩니다.
JS에서 파싱이 끝난 코드는 컴파일러를 거쳐 최적화된 이진 코드로 변환된 후 그림 [1-2]처럼 실행됩니다.

컴파일 단계에서는 JS가상 머신에 전달할 이진 바이트 코드가 생성됩니다.
JS 엔진은 파싱 이후 생성된 코드를 다양한 방법으로 실행 전에 그때그때 JIT 처리 및 최적화한다는 점입니다.
이런 JS 엔진 작동 방식으로 인해 관점에 따라 JS를 컴파일 언어 혹은 인터프리터 언어라고 할 수 있는 거죠.

#### JS로 만든 소스 코드가 실행될 때가지 어떤 절차를 거치는 지 정리

1. 개발자의 손을 떠난 코드는 트랜스파일합니다. 이후 웹팩을 비롯한 번들러를 거쳐 번들링되고, 그 결과가 JS엔진에 전달됩니다.
2. JS엔진은 전달받은 코드를 파싱해 추상 구문 트리로 바꿉니다.
3. 이어서 엔진은 추상 구문 트리를 이진 바이트 코드로 바꿉니다. 이과정에서 JIT컴파일러가 작동하여 최적화가 함께 진행됩니다.
4. 마지막으로 JS 가상 머신이 프로그램을 실행합니다.

필자는 JS가 컴파일 언어라고 생각한다함.
컴파일 언어라고 생각하는 게 중요한지는 서두에서 언급했습니다.
코드 실행 전에 정적 오류를 미리 발견할 수 있다는 특징이 있기 때문입니다.

### 1.6.1 웹어셈브리

2013년 모질라 재단에서 파이어폭스를 개발하던 엔지니어들은 C로 작성된 언리얼 엔진3을 JS로 바꿔 시연했다.
포팅한 엔진을 브라우저에서 돌렸을 때 성능은 최대 60fps까지 나왔는데, 이게 가능했던 이유는 언리얼 엔진3 JS버전의 코드가 ASM.js 라 부르는 JS 부분집합에 친화적으로 개발되었기 때문입니다.

모질라 재단의 엔지니어를 시작으로 여러 엔지니어 그룹이 웹어셈블리(Wasm)라는 기술을 공개하기 시작함
Wasm은 JS가 주력이 아닌 개발자도 JS엔진에서 돌아가는 코드를 쉽게 작성할 수 있게 해주는 데 그 목적이 있었고, 이는 ASM.js의 철학과 유사합니다.
다만 Wasm은 일반 JS와는 완전히 다른 프로그램 형태로 제작되어 실행 전 단계인 파싱과 컴파일을 거치지 않아 파싱과 컴파일에 따른 본질적인 지연을 피한다는데 있어 ASM.js 와 다릅니다.

Wasm은 이름에 알 수 있듯이 어셈블리 언어와 유사하며 JS엔진에서 일어나는 일반적인 처리 프로세스와 달리 파싱, 컴파일 없이 처립됩니다. Wasm으로 만든 프로그램의 파싱,컴파일은 실행직전에 일어나고 배포는 JS 엔진의 별도 처리가 많이 필요하지 않은 바이너리 파일 형식으로 진행됩니다.

간단히 한마디만 하자면 Wasm은 JS를 대체하지 못할 것 입니다.

<br>

## 1.7 엄격 모드

2009년, 엄격모드를 사용할 수 있게 되면서 더 나은 JS프로그램을 만들기 위한 장치가 마련되었습니다.
10년이 지난 지금 엄격모드는 기본이 아닌 선택사항입니다.

그렇다면 왜 엄격모드를 사용해야 할까요 ?? 엄격모드는 JS엔진이 코드를 최적화하고 효율적으로 실행할 수 있게 해주는 '최고의 안내 가이드 역활을 하는 모드' 입니다. JS 코드 대부분은 다양한 개발자에 의해 작성됩니다.
이런 상황에 린터 같은 도구를 사용해 엄격 모드로 작업한다면 엄격함 덕분에 비엄격 모드에서 발생할 수 있는 실수와 문제를 미연에 방지할 수 있어 협업이 수월합니다.

엄격 모드에서만 활성화되는 가이드 대부분은 초기오류의 형태를 띠는데, 초기 오류는 엄밀히 말해 구문 오류는 아니지만 코드 실행 전 컴파일 단계에서 잡아낼 수 있는 오류를 의미

파일 대상으로 적용되는 엄격모드는 전처리 구문 "use strict"가 있는 경우에 활성화됩니다.

```
// 전처리 구문 use strict 앞에는 공백이나 주석만 올 수 있습니다.
"use strict"
// use strict 때문에 나머지 코드는 이제 엄격 모드로 작동합니다.
```

한편 엄격모드는 함수 단위로도 적용할 수 있습니다.

```
funciton someOpre(){
// 공백이나 주석만 이곳에 올 수 있습니다.
"use strict"
// 나머지 코드는 이제 엄격 모드로 작동합니다.
}
```

흥미로운 사실은 파일 단위 엄격 모드가 적용되면 함수에는 엄격 모드 전처리 구문을 사용할 수 없다는 점입니다.
둘 중 하나를 택해야 함.

필자는 JS에서 엄격 모드가 기본 모드가 될 날이 오지 않을거라고 생각한다.
엄격 모드가 기본이 되면 기존 코드가 엄격 모드 가이드로 인해 작동하지 않을 위험이 있음
그런데 다행히도 엄격 모드가 기본이 아니어서 발생할 수 있는 "불확실성"을 줄여주는 여러요인이 있음

1. 원본 코드가 비엄격 모드에서 작성되었다 하더라도 사실상 트랜스파일 처리된 코드는 엄격 모드를 준수한다는 점
   상용 환경에 배포하는 JS 코드 대부분은 트랜스 파일 처리됩니다. 그렇기 때문에 상용 환경의 JS 코드 대부분은 이미 엄격 모드를 준수한다고 가정 할 수 있음
2. 요즘에 코드를 작성할 때 ES6 모듈 형식으로 작성하는 경우가 많고 이런 현상 때문에 불확실성이 점차 줄어들고 있음 왜냐하면 ES6 모듈은 기본이 엄격모드이므로 ES6 모듈 형식으로 만든 파일은 자동으로 엄격 모드를 준수하기 때문입니다.

<br>

## 1.8 정리
