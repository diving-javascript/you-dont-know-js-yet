# 1. 자바스크립트

<br>

- [1. 자바스크립트](#1-자바스크립트)
  - [1.1 책에 대하여](#11-책에-대하여)
  - [1.2 자바스크립트 이름의 유래](#12-자바스크립트-이름의-유래)
  - [1.3 명세서](#13-명세서)
    - [참조](#참조)
    - [1.3.1 JS를 지배하는 웹](#131-js를-지배하는-웹)
    - [참조](#참조-1)
    - [1.3.2 JS지만 JS가 아닌 웹 전용 문법](#132-js지만-js가-아닌-웹-전용-문법)
    - [1.3.3 모든 코드가 JS인 것은 아닙니다.](#133-모든-코드가-js인-것은-아닙니다)
  - [1.4 JS의 다양한 얼굴](#14-js의-다양한-얼굴)
  - [1.5 `하위 호환성`과 `상위 호환성`](#15-하위-호환성과-상위-호환성)
  - [1.6 인터프리터 이해하기](#16-인터프리터-이해하기)
  - [1.7 엄격 모드](#17-엄격-모드)
  - [키워드](#키워드)

<br>


## 1.1 책에 대하여

```bash
시간을 들여 이 책에서 다른는 내용을 완전히 내 것으로 만들기 바랍니다.
첫 단추를 잘 끼워야 한다는 점을 잊지마세요.
# p. 30
```

<br>

## 1.2 자바스크립트 이름의 유래

```bash
자바스크립트는 이미 알려져 있고,
무거운 언어였던 자바개발자들의 입맛에 맞게 만들었고,
개발자들에게 어필하기 위해 마케팅 목적으로 고안해낸 이름이다.
# p. 31
```

```bash
JS를 자바스크립트, ECMASCript, ES2019 중 무엇으로 부르든
자바와 자바스크립트는 관계가 없습니다.
# p. 32
```

<br>

## 1.3 명세서

```bash
TC39(Ecma International Technical Committee 39)는 JS를 관리하는 기술 운영 위원회로,
자바스크립트의 공식 명세를 관리합니다.
# p. 32
```

```bash
JS에는 버전이 없습니다.
TC39와 ECMA에 의해 유지되는 공식적인 표준 JS는 단 하나뿐이다.
# p. 33
```

```bash
브라우저 엔진별로 명세서 개정안을 반영하는 시기가 다르긴 하지만,
규칙을 어기는 일은 절대 없어야 한다.
# p. 33
```

### 참조

- [TC39](https://tc39.es/)
- [TC39 Process](https://tc39.es/process-document/)
- [ECMAScript proposals](https://github.com/tc39/proposals)

### 1.3.1 JS를 지배하는 웹

```bash
JS는 브라우저나 서버(Node.js), 심지어 로봇이나 전구에서도 실행되고 점차 그 영역을 확장하고 있습니다.
하지만 이들 중 가장 큰 비중을 차지 하는 분야는 단연코 웹입니다.
따라서 JS 구현체를 만들 때는 웹 브라우저 환경을 가장 중요하게 고려해야 합니다.
# p. 34
```

```bash
이런 문제는 ECMAScript 명세서와 실제 웹에서 돌아가는 JS의 차이가 상세히 기록되어 있는
명세서 페이지의 부록 B, Additional ECMAScript Features for Web Browsers를 참고해 해결할 수 있습니다.
# p. 35
```

```bash
가급적 특정 JS엔진에 종속되지 않으면서 명세서를 준수하는 구현체만 사용하도록 합시다.
# p. 35
```

### 참조

- TC39 Smooshgate 케이스: [ECMA TC39: “SmooshGate” was officially resolved by renaming flatten to flat](https://developer.chrome.com/blog/smooshgate)
- [B, Additional ECMAScript Features for Web Browsers](https://tc39.es/ecma262/multipage/additional-ecmascript-features-for-web-browsers.html)


### 1.3.2 JS지만 JS가 아닌 웹 전용 문법

```bash
브라우저 엔진, Node.js 등과 같이 JS가 실행되는 환경은 
전역 스코프에 API를 추가해 자체적으로 사용할 수 있는 기능을 제공합니다.
alert() 함수가 바로 여기에 해당합니다. 
사실 JS처럼 보이는 API 상당수가 실제로는 웹에서만 지원되는 API인 경우가 많습니다.
fetch(), getCurrentLocation(), getUserMedia()가 대표적인 예입니다.
Node.js 환경 역시 fs.write() 같은 다양한 빌트인 모듈을 제공해 개발자가 편리하게 API를 쓸 수 있도록 지원합니다.
이와 같이 명세서에는 없지만 JS처럼 인식되는 대표적인 메서드로 console.*가 있습니다.
# p. 35~36
```

```bash
동작의 이면은 해당 코드가 돌아가는 환경에 의해 달라지긴 하지만 JS라는 생테계에 속하려면 표면상 JS 문법 규칙을 준수해야 합니다.
# p. 36
```

### 1.3.3 모든 코드가 JS인 것은 아닙니다.

```bash
개발자 도구가 JS의 프로그램 처리 방식을 항상 엄격하게 준수하지 않는다는 점과 이를 기대해서도 안 된다는 점을 지적하려고 합니다.
왜냐하면 개발자 도구가 이를 목표로 만들어진게 아니기 때문입니다.
# p. 37
```

```bash
개발자 도구가 순수 JS 동작 방식을 보장하지 않는다는 점을 알아보기 위해 환경별 차이 몇가지만 간단히 살펴보겠습니다.
- 콘솔 '전역 스코프' 최상위 레벨에서 var나 function으로 변수나 함수를 선언하면 실제 전역에 변수가 생기는지 여부(그리고 이 변수가 window 프로퍼티 속성을 지원하는지, 그 역은 성립하는지 여부)
- '전역 스코프' 최상위 레벨에서 let과 const로 변수 여러 개를 선언했을 때 작동방식
- 첫번째 줄에 'use strict' 를 입력한 후에 엔터를 눌렀을 때, .js 파일 첫번째 줄에 'use strict'를 입력한 것처럼 해당 콘솔 섹션이 엄격 모드로 작동하는지 여부와 첫번째가 아닌 다른 줄에 'use strict'를 입력해도 해당 세션이 엄격모드로 작동하는지 여부
- 비엄격 모드에서 함수를 호출할 때 this의 기본 바인딩 방식과 '전역 객체'가 쓰이는 경우, 실제 기대한느 전역 변수가 이 전역 객체에 있는지 여부
- 여러 줄을 입력할 때 호이스팅의 작동방식
- 기타 등등..
# p. 37
```

```bash
콘솔에 입력한 코드는 JS엔진이 .js파일을 다루는 방식과 동일한 방식으로 처리되지 않습니다.
콘솔의 목적은 개발자가 짧은 코드를 입력하고 그 결과를 즉시 확인하기 위함입니다.
JS엔진과 콘솔의 유스 케이스는 완전히 다릅니다.
# p. 37
```

<br>

## 1.4 JS의 다양한 얼굴

<br>

## 1.5 `하위 호환성`과 `상위 호환성`

<br>

## 1.6 인터프리터 이해하기

<br>

## 1.7 엄격 모드

<br>

## 키워드
