# 1. 자바스크립트

<br>

- [1. 자바스크립트](#1-자바스크립트)
  - [1.1 책에 대하여](#11-책에-대하여)
  - [1.2 자바스크립트 이름의 유래](#12-자바스크립트-이름의-유래)
  - [1.3 명세서](#13-명세서)
    - [1.3.1 JS를 지배하는 웹](#131-js를-지배하는-웹)
    - [1.3.2 JS지만 JS가 아닌 웹 전용 문법](#132-js지만-js가-아닌-웹-전용-문법)
    - [1.3.3 모든 코드가 JS인 것은 아닙니다.](#133-모든-코드가-js인-것은-아닙니다)
  - [1.4 JS의 다양한 얼굴](#14-js의-다양한-얼굴)
  - [1.5 `하위 호환성`과 `상위 호환성`](#15-하위-호환성과-상위-호환성)
  - [1.6 인터프리터 이해하기](#16-인터프리터-이해하기)
  - [1.7 엄격 모드](#17-엄격-모드)
  - [키워드](#키워드)
  - [참고](#참고)

<br>


## 1.1 책에 대하여

> 시간을 들여 이 책에서 다른는 내용을 완전히 내 것으로 만들기 바랍니다. 첫 단추를 잘 끼워야 한다는 점을 잊지마세요.<br>
> **p. 30**


<br>

## 1.2 자바스크립트 이름의 유래

> 자바스크립트는 이미 알려져 있고, 무거운 언어였던 자바개발자들의 입맛에 맞게 만들었고, 개발자들에게 어필하기 위해 마케팅 목적으로 고안해낸 이름이다.<br>
> **p. 31**


> JS를 자바스크립트, ECMASCript, ES2019 중 무엇으로 부르든 자바와 자바스크립트는 관계가 없습니다.<br>
> **p. 32**

<br>

## 1.3 명세서

> TC39(Ecma International Technical Committee 39)는 JS를 관리하는 기술 운영 위원회로, 자바스크립트의 공식 명세를 관리합니다.<br>
> **p. 32**


> JS에는 버전이 없습니다.<br>
> TC39와 ECMA에 의해 유지되는 공식적인 표준 JS는 단 하나뿐이다.<br>
> **p. 33**


> 브라우저 엔진별로 명세서 개정안을 반영하는 시기가 다르긴 하지만, 규칙을 어기는 일은 절대 없어야 한다.<br>
> **p. 33**

### 1.3.1 JS를 지배하는 웹

> JS는 브라우저나 서버(Node.js), 심지어 로봇이나 전구에서도 실행되고 점차 그 영역을 확장하고 있습니다. 하지만 이들 중 가장 큰 비중을 차지 하는 분야는 단연코 웹입니다. 따라서 JS 구현체를 만들 때는 웹 브라우저 환경을 가장 중요하게 고려해야 합니다.<br>
> **p. 34**


> 이런 문제는 ECMAScript 명세서와 실제 웹에서 돌아가는 JS의 차이가 상세히 기록되어 있는 명세서 페이지의 부록 B, Additional ECMAScript Features for Web Browsers를 참고해 해결할 수 있습니다.<br>
> **p. 35**


> 가급적 특정 JS엔진에 종속되지 않으면서 명세서를 준수하는 구현체만 사용하도록 합시다.<br>
> **p. 35**



### 1.3.2 JS지만 JS가 아닌 웹 전용 문법

> 브라우저 엔진, `Node.js` 등과 같이 JS가 실행되는 환경은 전역 스코프에 API를 추가해 자체적으로 사용할 수 있는 기능을 제공합니다. `alert()` 함수가 바로 여기에 해당합니다.
> 사실 JS처럼 보이는 API 상당수가 실제로는 웹에서만 지원되는 API인 경우가 많습니다. `fetch()`, `getCurrentLocation()`, `getUserMedia()`가 대표적인 예입니다.
> `Node.js` 환경 역시 `fs.write()` 같은 다양한 빌트인 모듈을 제공해 개발자가 편리하게 API를 쓸 수 있도록 지원합니다. 이와 같이 명세서에는 없지만 JS처럼 인식되는 대표적인 메서드로 `console.*`가 있습니다.<br>
> **p. 35~36**


> 동작의 이면은 해당 코드가 돌아가는 환경에 의해 달라지긴 하지만 JS라는 생테계에 속하려면 표면상 JS 문법 규칙을 준수해야 합니다.<br>
> **p. 36**


### 1.3.3 모든 코드가 JS인 것은 아닙니다.

> 개발자 도구가 JS의 프로그램 처리 방식을 항상 엄격하게 준수하지 않는다는 점과 이를 기대해서도 안 된다는 점을 지적하려고 합니다. 왜냐하면 개발자 도구가 이를 목표로 만들어진게 아니기 때문입니다.
> **p. 37**

> 개발자 도구가 순수 JS 동작 방식을 보장하지 않는다는 점을 알아보기 위해 환경별 차이 몇가지만 간단히 살펴보겠습니다.
> - 콘솔 '전역 스코프' 최상위 레벨에서 var나 function으로 변수나 함수를 선언하면 실제 전역에 변수가 생기는지 여부(그리고 이 변수가 window 프로퍼티 속성을 지원하는지, 그 역은 성립하는지 여부)
> - '전역 스코프' 최상위 레벨에서 let과 const로 변수 여러 개를 선언했을 때 작동방식
> - 첫번째 줄에 'use strict' 를 입력한 후에 엔터를 눌렀을 때, .js 파일 첫번째 줄에 'use strict'를 입력한 것처럼 해당 콘솔 섹션이 엄격 모드로 작동하는지 여부와 첫번째가 아닌 다른 줄에 'use strict'를 입력해도 해당 세션이 엄격모드로 작동하는지 여부
> - 비엄격 모드에서 함수를 호출할 때 this의 기본 바인딩 방식과 '전역 객체'가 쓰이는 경우, 실제 기대한느 전역 변수가 이 전역 객체에 있는지 여부
> - 여러 줄을 입력할 때 호이스팅의 작동방식
> - 기타 등등..
> **p. 37**

> 콘솔에 입력한 코드는 JS엔진이 .js파일을 다루는 방식과 동일한 방식으로 처리되지 않습니다. 콘솔의 목적은 개발자가 짧은 코드를 입력하고 그 결과를 즉시 확인하기 위함입니다. JS엔진과 콘솔의 유스 케이스는 완전히 다릅니다.<br>
> **p. 37**


<br>

## 1.4 JS의 다양한 얼굴

> 프로그래밍 분양에서 '패러다임(paradigm)'이라는 용어는 코드를 어떻게 구조화할지에 대한 접근방식과 사고 방식을 의미합니다.<br>
> **p. 38**

> 절차적(procedural) 프로그래밍 패러다임에서는 코드가 톰다운(top-down)이면서 선형적(linear)으로 구조화 되는데, 이때 프로시저(procedure)라 불리는 코드 단위에 미리 정해진 일련의 연산을 작성합니다.<br>
> **p. 38**

> 객체(object-oriented) 프로그래밍 패러다임에서는 클래스 기준으로 코드를 구조화하며, 클래스에서는 로직과 데이터가 정의됩니다.<br>
> **p. 38**

> 함수형(functional) 프로그래밍 패러다임에서는 코드를 함수 단위로 구조화합니다. 이때 함수는 (절차적 프로그래밍의 함수와 달리) 부수 효과가 없는 순수 함수 입니다. 또한 함수 자체가 값으로 취급된다는 특징이 있습니다.<br>
> **p. 38**

> 패러다임에는 옳고 그름이 없습니다. 패러다임은 개발자가 문제와 해결책에 접근하는 방법과 코드를 구성하고 유지 보수하는 방법을 안내하는 표지판 같은 역할을 할 뿐입니다.<br>
> **p. 38**

> 이처럼 특정한 페러다임에 치우친 언어도 있지만, 여러 패러다임을 사용해 코드를 구조화 할 수 있도록 지원합니다. 이런 언어를 다중 패러다임 언어(multi-paradigm language)언어라고 부르며 궁극의 유연성을 제공합니다.<br>
> **p. 38**


<br>

## 1.5 `하위 호환성`과 `상위 호환성`

<br>

## 1.6 인터프리터 이해하기

<br>

## 1.7 엄격 모드

<br>

## 키워드

<br>

## 참고

- [TC39](https://tc39.es/)
- [TC39 Process](https://tc39.es/process-document/)
- [ECMAScript proposals](https://github.com/tc39/proposals)
- TC39 Smooshgate 케이스: [ECMA TC39: “SmooshGate” was officially resolved by renaming flatten to flat](https://developer.chrome.com/blog/smooshgate)
- [B, Additional ECMAScript Features for Web Browsers](https://tc39.es/ecma262/multipage/additional-ecmascript-features-for-web-browsers.html)
