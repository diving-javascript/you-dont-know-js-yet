## 스코프(범위; Scope)

- 변수 스코프(범위; Scope)를 설정하는 것은 함수 또는 블록 단위로 이루어지며, 이는 모든 언어에서 가장 기본적인 특징 중 하나입니다. 이 특징은 아마도 프로그램이 어떻게 동작하는지에 가장 큰 영향을 미칩니다.

- 스코프(범위; Scope)를 양동이라고 비유하면, 변수는 그 양동이에 넣는 구슬과 같습니다. 언어의 스코프 모델은 어떤 색상의 구슬이 어떤 동일한 색상의 양동이에 들어갈지를 결정하는 규칙과 같습니다.

- 스코프는 서로 중첩될 수 있으며, 특정 표현식(expression)이나 문장(statement)에 대해 해당 스코프 또는 그 이상의 외부 스코프에서만 변수에 접근할 수 있습니다. 반면, 더 낮은 또는 내부 범위의 변수는 숨겨져 있어 접근할 수 없습니다.

    **[예제]**

    ```jsx
    let outerVar = "저는 외부 변수입니다!"; // 외부 범위에서 정의됨

    function outerFunction() {
        let innerVar = "저는 내부 변수입니다!"; // 내부 범위에서 정의됨

        console.log(outerVar); // 외부 범위에 있기 때문에 접근 가능
        console.log(innerVar); // 같은 범위에 있기 때문에 접근 가능

        function innerFunction() {
            let innermostVar = "저는 가장 깊은 내부 변수입니다!"; // 가장 깊은 내부 범위에서 정의됨

            console.log(outerVar); // 외부 범위에 있기 때문에 접근 가능
            console.log(innerVar); // 외부 범위에 있기 때문에 접근 가능
            console.log(innermostVar); // 같은 범위에 있기 때문에 접근 가능
        }

        innerFunction();

        // console.log(innermostVar); // 이 범위에서는 innermostVar에 접근할 수 없으므로 오류가 발생함
    }

    outerFunction();

    ```

    > 이 코드에서, `outerVar`는 가장 외부 범위에서 정의되었으므로 어디에서든 접근 가능합니다. `innerVar`는 `outerFunction`과 `innerFunction`에서만 접근 가능하며, 이는 `innerFunction`에 비해 외부 범위에 정의되었기 때문입니다. `innermostVar`는 가장 내부 범위에서 정의되었으므로 `innerFunction`에서만 접근 가능합니다.

    <div align="center">
        <img src="./public/4-1_scope.png" alt="결과" width="600" height="auto"/>
    </div>

<br>

## 렉시컬 스코프(Lexical scope)

- 렉시컬 스코프는 대부분의 언어에서 범위가 어떻게 작동하는지를 나타냅니다. 스코프의 경계와 변수 구성은 프로그램이 파싱(컴파일)되는 시점에 결정됩니다. 이는 작성 시점에서 결정되는 사항입니다. 프로그램에서 함수나 범위의 위치에 따라 해당 프로그램 일부의 범위 구조가 결정됩니다.

    **[예제]**

    ```jsx
    let name = "전역 변수";  // 전역 변수

    function outerFunction() {
        let name = "outerFunction 스코프의 지역 변수";  // outerFunction 스코프의 지역 변수

        function innerFunction() {
            console.log(name);  // outerFunction 스코프의 'name'에 접근
        }

        innerFunction();  // 출력: "outerFunction 스코프의 지역 변수"
    }

    outerFunction();

    console.log(name);  // 출력: "전역 변수" - 전역 변수에 접근
    ```

    > 스코프의 경계와 변수 구성은 프로그램이 파싱(컴파일)되는 시점에 결정되며, 따라서 작성 시점에서 결정됩니다. 코드에서 `name`이라는 변수는 두 번 선언되었지만, 각 변수는 서로 다른 스코프에 있습니다. `name` 변수는 전역 스코프와 `outerFunction`의 함수 스코프에 각각 선언되었습니다. `innerFunction`은 `outerFunction`의 스코프에 접근할 수 있으므로 `outerFunction` 스코프의 `name` 변수를 출력합니다. 반면, `outerFunction`을 호출한 후의 `console.log(name);`는 전역 스코프의 `name` 변수를 참조하므로 "전역 변수"를 출력합니다.

- JS is lexically scoped, though many claim it isn't, because of two particular characteristics of its model that are not present in other lexically scoped languages.

<br>

## 호이스팅(Hosting)

- 호이스팅은 자바스크립트에서 변수나 함수를 선언하기 전에도 사용할 수 있게 하는 중요한 특성입니다. 이는 선언된 변수와 함수가 자동으로 해당 범위의 맨 위로 이동되기 때문입니다. 이 특성 덕분에 변수나 함수를 선언하기 전에 미리 참조하거나 호출할 수 있습니다. 그러나 변수는 선언되기 전에 `undefined` 상태이므로, 선언 없이 사용하면 예상치 못한 결과를 초래할 수 있습니다. 반면에 함수의 경우, 호이스팅이 발생하면 함수의 전체 본문이 함께 이동하므로 선언 전에도 호출할 수 있습니다.

    **[예제: 변수]**
    
    ```jsx
    console.log(myVar); // 출력: undefined

    myVar = 5; // myVar에 5를 할당

    console.log(myVar); // 출력: 5

    var myVar; // myVar 선언
    ```

    > 이 코드에서 변수 `myVar`는 스코프의 상단으로 호이스팅됩니다. 이는 변수가 선언되기 전에도 사용이 가능하다는 것을 의미합니다. 하지만 이 변수는 명시적으로 값이 할당되는 부분까지 `undefined` 상태로 유지됩니다. 때문에, 변수 `myVar`는 선언되지 않았음에도 불구하고 코드 상의 위치에 관계없이 사용이 가능하며, 실제 값이 할당되기 전까지는 `undefined`라는 값을 가지게 됩니다.

    **[예제: 함수]**

    ```jsx
    // 함수 선언 전에 함수 호출
    greet();

    // 함수 선언
    function greet() {
    console.log("Hello, World!");
    }
    ```

    > 이 코드에서, `greet()` 함수는 선언되기 전에 호출되었습니다. 그러나 자바스크립트의 함수 호이스팅 때문에 함수 선언이 스코프의 상단으로 이동하여, 선언 전에도 호출할 수 있게 됩니다.


### 참고

- [Stack overflow: Lexical scope and Hoisting in javascript](https://stackoverflow.com/questions/47163068/lexical-scope-and-hoisting-in-javascript)
- [Stack overflow: Javascript function scoping and hoisting](https://stackoverflow.com/questions/7506844/javascript-function-scoping-and-hoisting)
- [FreeCodeCamp: Lexical Scope in JavaScript](https://www.freecodecamp.org/news/lexical-scope-in-javascript/#:~:text=The%20process%20of%20determining%20the,two%20things%3A%20parsing%20and%20execution%20.)

<br>

## 클로저(Closure)


### 참고

- [MDN: Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)