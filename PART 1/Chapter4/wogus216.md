# CHAPTER 4 더 큰 그림

<br>

- [CHAPTER 4 더 큰 그림](#chapter-4-더-큰-그림)
  - [4.1 스코프와 클로저](#41-스코프와-클로저)

<br>

## 4.1 스코프와 클로저

스코프는 양동이, 변수는 양동이에 넣을 구슬에 비유할 수 있습니다. 이때 언어 고유의 스코프모델은 구슬과 같은 색을 가진 양동이를 찾도록 도와주는 규칙입니다.

- 렉시컬 스코프: 함수가 선언된 시점에서의 변수의 범위를 기준으로 결정되는 변수의 접근성을 설명하는 프로그래밍 용어입니다. 이는 함수를 어디서 호출하였는지가 아니라, 어디에 선언하였는지에 따라 함수의 실행 환경이 결정된다는 의미를 갖습니다.

즉, 개발자가 코드를 작성할 때 결정됩니다. 개발자가 함수나 스코프를 프로그램 내 어디에 배치하느냐에 따라 프로그램 내 해당 코드의 스코프구조가 결정되는 것이죠.

```
var x = 1;

function foo() {
	var x = 10;
	bar();
}

function bar() {
	console.log(x);
}

foo(); // 1
bar(); // 1
```

bar에 있는 변수 x가 foo 함수에서 var x =10; 있어서 x변수가 foo()를 호출시 10이 나올 것 같지만 예상 다르게 1이 나왔다. 이것이 렉시컬 스코프의 핵심이다. 어디서 호출되는지가 아니라 어디서 선언되었는지에 따라 결정 된다는 것이다. bar 함수내의 x는 전역 변수 x를 참조한다.

JS는 렉시컬 스코프 모델을 채택하고 있긴 하지만 가은 모델을 사용하는 여타 언어들과는 다른 두 가지 특징을 갖습니다.

- 첫 번째 특징-호이스팅: 특정 스코프 내에 선언한 변수가 선언된 위치와 상관없이 해당 스코프 시작 부분에서 선언한 것 마냥 처리되어 호이스팅이란 이름이 붙었습니다.
- 두 번째 특징-var 변수: 해당 변수를 선언한 블록위치와 상관없이 함수 기준으로 스코프가 만들어진다는 점,
  var로 선언된 변수는 선언과 동시에 undefined로 초기화 된다.
  let과 const는 호이스팅이 되지만, 초기화되기 전까지는 접근할 수 없는 "일시적 사각지대" (Temporal Dead Zone, TDZ)라는 특성이 있습니다. 이를 통해 변수가 선언되기 전에 접근하는 것을 방지

  ```
  console.log(a); // undefined
  var a;
  a = 10;
  console.log(a); // 10;
  ```

---

console.log(b); // Uncaught ReferenceError: b is not defined
let b;
console.log(b); // undefined;
b = 20;
console.log(b); // 20;

```
<br>



## 4.2 프로토 타입

JS를 지탱하는 두 번째 기둥은 프로토타입 시스템입니다.
JS는 클래스를 통해 사전에 구조를 정의하지 않아도 직접적이고 명시적으로 객체를 만들 수 있는 몇 안되는 언어 중 하나입니다.

과거 몇 년간 개발자들은 프로토타입을 사용해 프로토타입 상속이라 부르는 클래스 디자인 패턴을 구현 해옴
그런데 ES6에서 class 키워드가 등장하면서 JS를 객체 지향/클래스 스타일로 개발하자는 움직임이 심화되었습니다.

JavaScript는 클래스 기반 언어가 아닌 프로토타입 기반 언어로, 모든 객체는 다른 객체로부터 속성과 메서드를 상속받습니다. 이 상속을 가능하게 하는 것이 프로토타입입니다.
<br>

## 4.3 타입과 타입 강제 변환

<br>

## 4.4 JS의 본질 따르기

<br>

## 4.5 학습 순서
```
