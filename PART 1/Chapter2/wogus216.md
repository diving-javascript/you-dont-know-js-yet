# 2. 자바스크립트 조망하기

<br>

- [2. 자바스크립트 조망하기](#2-자바스크립트-조망하기)
  - [2.1 파일은 프로그램입니다.](#21-파일은-프로그램입니다)
  - [2.2 값](#22-값)
    - [2.2.1 배열과 객체](#221-배열과-객체)
    - [2.2.2 값의 타입](#222-값의-타입)
  - [2.3 변수 선언과 사용](#23-변수-선언과-사용)
  - [2.4 함수](#24-함수)
  - [2.5 비교](#25-비교)
    - [2.5.1 같음에 대한 고찰](#251-같음에-대한-고찰)
    - [2.5.2 강제 변환](#252-강제-변환)
  - [2.6 코드 구조화 패턴](#26-코드-구조화-패턴)
    - [2.6.1 클래스](#261-클래스)
    - [상속](#상속)
    - [2.6.2 모듈](#262-모듈)
  - [2.7 더 깊은 토끼 굴로](#27-더-깊은-토끼-굴로)

<br>

## 2.1 파일은 프로그램입니다.

js에서는 파일 각각 별도의 프로그램입니다.
파일을 각각 프로그램으로 봐야하는게 중요한 이유는 주로 오류처리와 관련이 있습니다.
JS는 파일을 프로그램으로 취급하기 때문에 파일 하나에만 오류가 있어도 (파싱/컴파일 또는 실행단계에서) 다음 파일이 처리되지 않을 수 있습니다. 따라서 각 파일이 제대로 작동하는 지 확인하고, 오류가 발생하더라도 최대한 우아하게 처리하는 게 중요합니다.

독립적인 .js파일 여러 개를 하나의 프로그램으로서 작동시키는 유일한 방법은 전역 스코프를 사용해 파일 간 상태를 공유하고, 공통으로 사용하는 기능을 접근 할 수 있도록 만드는 방법뿐입니다.

모듈(상태와 외부에 노출할 용도로 만든 상태 조작 메서드의 모음)을 하나의 독립적이고 실행 가능한 프로그램이라고 생각하지 않는 개발자가 있을 수 있습니다. 하지만 js는 각 모듈을 별도로 처리합니다.
단일 파일이든 모듈이든, 어떤 코드 구성 패턴과 로딩 메커니즘을 사용하든 관계없이 파일 하나를 제3의 작고 독립적인 프로그램과 협력해 프로그램 전체를 진동시키는 고유한 작은 프로그램이라고 생각합니다.
<br>

## 2.2 값

js에서 값은 크게 원시타입과 객체 타입으로 분류됩니다.

js에서는 리터럴을 사용해 프로그램에 값을 주입합니다.
코드 가독성과 유지보수를 위해 프로그램 전반에 걸쳐 일관성 있는 표기법를 사용해야 한다는 것은 잊지 말아야합니다.

```
console.log("제 이름은 ${firstName}입니다.")
// 제 이름은 ${firstName}입니다.

console.log('제 이름은 ${firstName}입니다.')
// 제 이름은 ${firstName}입니다.

console.log(`제 이름은 ${firstName}입니다.`)
// 제 이름은 카일입니다.

```

변수 firstName에 '카일'이라는 값이 저장되어 있다는 가정하에 코드를 실행하면 백틱으로 감싼 문자열만 문자열 내 변수 표현식인 ${...} 부분이 현잿값(카일)으로 대체 되면서 제 이름은 카일입니다. 이런방식을 보간법이라 합니다.

백틱은 보간 표현식없이 사용할 수도 있지만 이는 백틱이 만들어진 목적과 부합하지 않으므로 권장하지 않습니다.

JS는 문자열,숫자, 불리언 이외에도 null과 undefined라는 원시 타입을 지원합니다. null과 undefined는 역사적 이유로 인한 차이가 있긴 한데, 대부분의 경우 두 타입 모두 값의 비어 있음(혹은 존재하지 않음)을 나타내는 데 사용합니다.

비어있는 단일 값을 나타낼 때는 undefined를 사용하는게 가장 안전한 최선의 방법입니다.

### 2.2.1 배열과 객체

배열에는 원시 타입, 객체 타입 상관없이 모든 타입의 값이 들어갈 수 잇습니다.
함수는 값이므로 배열이나 객체의 값에 함수 역시 할당할 수 있습니다.

### 2.2.2 값의 타입

typeof 연산자를 사용해 원시 타입 값과 객체 타입 값을 구분합니다.

> typeof null은 예상과 달리 "null"이 아닌 "object"를 반환합니다. --> 버그
> 변수에 할당하거나 어딘에 넘길 때, 원싯값과 객체의 작동 방식은 차이가 있습니다.
> <br>

## 2.3 변수 선언과 사용

변수는 값을 담는 상자라고 생각하면 됩니다.

let과 var로 선언한 변수는 접근 범위 측면에서 가장 큰 차이를 보입니다. let으로 선언한 변수는 var로 선언한 변수보다 접근 범위가 한정됩니다. var로 선언한 변수는 접근 범위가 함수 스코프 인데 반해 let으로 선언한 변수는 변수 접근 범위가 블록입니다. 이런 let의 특징을 블록 스코프라고 부릅니다.

var,let 말고도 const를 사용해 변수를 선언할 수 있습니다. const는 let과 유사한데, 선언되는 순간에 값을 할당해야 하고 나중에 다른 값을 재할당할 수 없다는 점에서 차이가 있습니다.

```
const myBirthday =true;
let age = 39;
if(myBirthday){
  age = age + 1; // age는 let으로 선언 했으므로 값 재할당이 가능합니다.
  myBirthday = false; // 오류가 발생합니다!

}
```

const로 선언한 변수는 재할당이 불가능할 뿐이지 값을 바꿀 수 없는 건 아닙니다.
이런 관점에서 봤을 때 const를 사용해 객체를 정의하는 건 좋지 않은 방식입니다.
객체를 재할당하는 건 불가능하지만 값은 바꿀수 없기 때문이니다.
그러니 const를 사용해 객체를 정의하는 건 피하도록 합시다.

```
const actors = [
  "모건 프리먼","제니퍼 애니스턴"
]

actors[2]= "톰 크루즈"; // 정상작동
actors = [] // 오류 발생
```

> const를 원싯값을 저장하는 용도로만 사용하면 재할당과 값 변경과 관련 혼란을 피할 수 있습니다.
> <br>

## 2.4 함수

js로 개발할 때 우리는 함수보다 좀 더 포괄적인 개념인 "프로시저"를 프로그램에 녹여내기 위해 심사숙고하며 함수를 작성해야 합니다.

> 프로시저 > 한 번 이상 호출할 수 있고 입력값이 있을 수 있으며 하나 이상의 출력값을 반환하는 구문의 모음을 의미합니다.

js 태동기에는 함수를 다음과 같이 정의할 수 있었습니다.

```
function awesomeFunction(coolThings){
  //...
  return amazingStuff;
}
```

이런 방식을 함수 선언 또는 함수 선언문이라고 하는데, 함수 선언이란 이름은 이 함수가 다른 문의 표현식이 아니라 문 자체이기 때문에 붙게 되었습니다.
함수 선언으로 정의한 함수 awesomeFunction은 식별자 awesomeFunction과 실제 함수를 나타내는 값의 연관이 코드 실행 단계가 아닌 컴파일 단계에서 맺어집니다.

```
// let awesomeFunction =...
// const awesomeFunction = ...
var awesomeFunction = function(coolThings){
  // ...
  return amazingStuff
}
```

함수 표현식으로 선언한 함수가 함수 선언으로 선언한 함수와 다른 점은 함수와 함수 식별자가 코드가 실행되기 전까지는 관계를 맺지 않는다는 점입니다.
js 함수는 객체의 한 종류입니다. js 같이 함수형 프로그래밍 패러다임을 지원하는 언어에서는 함수를 값으로 취급하는 게 필수 입니다.
<br>

## 2.5 비교

프로그램은 값을 비교해 값의 정체와 값 사이의 관계를 파악한 후 의사결정을 내립니다.

### 2.5.1 같음에 대한 고찰

여러가지 이유로 JS에서 같음은 '서로 다르지 않음'이라는 사전적 의미보다 좀 더 복잡합니다.
그렇기 때문에 일치비교(===)와 동등 비교(==)의 차이를 알고 있어야 합니다.

예시

```
3 === 3.0          //true
"yes" === "yes"    //true
null === null;     //true
false === false;   //true

42 === "42";        // false
"hello" === "Hello";// false
true === 1          // false
0 === null;         // false
"" === null;        // false
null === undefined  // false
```

그런데 === 연산자가 특수한 값인 NaN이나 -0과 함께 사용되면 예상과 다르게 작동합니다.

```
NaN === NaN; // false
0 === -0;    // true

```

NaN을 만나면 === 연산자는 거짓말을 합니다.
-0 과 0 은 다르지만 === 연산자는 둘이 같다고 거짓말을 합니다.
NaN과 비교할 때는 거짓말을 하지 않는 Numer.isNaN()을 사용하고, -0과 비교할 때는 Object.is()를 사용하세요.

=== 연산자만 으로는 아주 정확하게 비교를 할 수 없다는 사실입니다.
한편, 원시 타입이 아닌 객체끼리 비교할 때는 상황이 조금 더 복잡해집니다.

```
[1,2,3] === [1,2,3] // false;
{a: 42} === {a:42}  // false;
(x => x * 2) === (x => x * 2) // false;
```

일치 비교는 값의 본질이나 내용을 비교한다고 볼 수 있습니다.
비교 대상이 객체인 경우에는 값의 본질이나 내용이 아닌 구조적일치를 비교하게 됩니다.

JS에서는 객체끼리 비교할 때 비교 연산자가 구조적 일치를 판단하지 않습니다.
대신 독자성 일치를 비교합니다.

```
var x = [1,2,3];

// 참조를 복사한 값이 할당되기 때문에 변수 y는 x의 복사본이 아닙니다.
// 변수 y는 x와 '같은' 배열을 참조합니다.

var y = x;

y === x ;      // true
y === [1,2,3]; // false
x === [1,2,3]; // false
```

예시에서 변수 y와 x가 모두 같은 배열에 대한 참조를 담고 있어 true를 반환합니다.
하지만 그 아랫줄의 === [1,2,3] 비교에서는 변수 y와 x 둘 다 각각 새로운 배열 [1,2,3]과 비교가 일어나기 때문에 false를 반환합니다. 중요한건 참조의 독자성입니다.

js에는 객체 구조가 같은 비교할 방법이 없습니다. 객체구조가 같은 지 비교하려면 직접 코드를 짜서 확인해야합니다.

### 2.5.2 강제 변환

강제 변환은 한 타입의 값이 다른 타입의 값으로 변하는 걸 의미합니다. 강제 변환은 JS를 지탱하는 커다란 기둥 중 하나입니다.

동등 연산자가 비교 대상이 되는 값의 타입을 고려하지 않고 비교를 수행한다는 아주 잘못된 정보로 인해 발생했습니다.
== 연산자는 === 연산자와 유사한 방식으로 피연산자가 같은지 비교합니다. 실제로 두 연산자 모두 피연산자의 타입을 비교합니다. 만약 피연산자가 같은 타입이라면 == 와 ===는 어떠한 차이도 없이 완전히 동일하게 작동합니다.

그런데 피연산자의 타입이 다른경우 == 연산자는 비교 이전에 강제로 타입을 맞추는 작업을 수행한다는 점에 === 연산자와 차이가 있습니다.

이런 면을 고려했을 때 필자는 == 연산자를 느슨한 동등 비교 연산자가 아닌 강제 동등 비교 연산자라고 설명하는 게 적합하다고 생각합니다.
<br>

## 2.6 코드 구조화 패턴

js 생태계 전반에 걸쳐 데이터와 행동관점에서 코드를 구조화하는 패턴은 크게 클래스와 모듈 두가지가 있습니다.

### 2.6.1 클래스

클래스는 사용자가 정의한 데이터타입으로 데이터와 이 데이터를 조작하는 동작이 들어갑니다.
그런데 클래스는 사용자 정의 데이터 타입이 어떻게 동작하는지 정의하긴 하지만 구체적인 값은 아닙니다.
프로그램에서 사용할 수 있는 구체적인 값이 필요하다면 new키워드를 사용해 인스턴스를 만들어야 합니다.

```
class Page{
  constructor(text){
    this.text= text;
  }
  print(){console.log(this.text)}
}

class Notebook{
  constructor(){
    this.pages = [];

  }

  addPage(text){
    var page = new Page(text);
    this.pages.push(page)
  }
  print(){
    for (let page of this.pages){
      page.print()
    }
  }
}

var mathNotes = new Notebook();
mathNotes.addPage("기초 연산: + - * / ...");
mathNotes.addPage("삼각법: sin con tan ...")

mathNotes.print()

```

클래스 매커니즘을 사용하면 데이터와 데이터의 동작을 한곳에 묶어 구조화 할 수 있습니다.
물론 클래스 없이도 동일한 결과물을 내주는 프로그램을 만들 수 있긴 합니다.
하지만 클래스가 없다면 체계적이지 않고 가독성이 떨어지며, 유지 보수하기 어려운 프로그램이 될 가능성이 높습니다.

### 상속

클래스 지향 설계는 상속과 다형성을 빼놓고 생각할 수 없습니다.

```
class Publication{
  constructor(title,author, pubDate){
    this.title = title;
    this.author= author;
    this.pubDate = pubDate;
  }

  print(){
    console.log(`
    제목: ${this.title}
    저자: ${this.author}
    발행일: ${this.pubDate}
    `)
  }
}
```

Publication 클래스에 출판에 필요한 동작이 정의되어 있습니다.
이번에는 좀 더 구체적인 출판 형태인 책이나 블로그 포스팅을 코드로 구현

```
class Book extends Publication{
  constructor(bookDetails){
    super(
      bookDetails.title,
      bookDetails.author,
      bookDetails.publishedOn
    );
    this.publisher = bookDetails.publisher;
    this.ISBN = bookDetails.ISBN;
  }

  print(){
    super.print();
    console.log(`
    출판사: ${this.publisher}
    ISBN: ${this.ISBN})
  }
}

class BlogPost extends Publication{
  contructor(title,author,pubDate,URL){
    super(title,author,pubDate);
    this.URL =URL;
  }

  print(){
    super.print();
    console.log(`URL: ${this.URL}`);
  }
}
```

Book과 BlogPost 클래스 모두 extends라는 키워드를 사용해 Publication 클래스에서 정의한 동작을 확장해서 사용하고 있습니다. 각 클래스 생성자 내에 있는 super()는 부모 클래스인 Publication의 생성자를 자식클래스에서도 사용할 수 있도록 코드를 다시 작성하지 않아도 출판 타입에 맞게 초기화 할 수 있습니다.

이번에는 자식 클래스를 사용한 예시

```
var YDKJSY = new Book({
  title: "You don't know JS yet",
  author: "카일 심슨",
  publishedOn: "2020년 1월",
  publisher: "독립 출판",
  ISBN: "979-8602477429:
});

YDKJSY.print();
// 제목:
// 저자:
// 발행일
// 출판사:
// ISBN:

var forAgaintLet = new BlogPost(
  "For and against let",
  "카일 심슨",
  "2014년 10월 27일",
  "https://davidwalsh.name/for-and-against-let"
)

forAgaintLet.print()
```

두 자식 클래스의 인스턴스를 통해 부모 클래스인 Publication 상속받아 새롭게 재정의한 메서드인 print()를 호출 할 수 있었다는 점입니다. 자식 클래스 Book과 BlogPost 각각에 정의된 메서드 print() 내부에서는 super.print()가 호출되면서 부모 클래스에 정의된 메서드 print()를 그대로 상속받아 사용합니다.

이렇게 상속 받은 메서드를 새롭게 정의한 메서드의 이름이 동일하고 공존할 수 있는 걸 다형성이라고 합니다.
상속은 클래스라는 독립된 논리적 공간에 데이터와 행동을 체계화 할 수 있도록 만드는 강력한 도구입니다.

### 2.6.2 모듈

모듈 패턴은 클래스와 마찬가지로 논리적 단위 기준으로 데이터와 행동을 그룹화 하는데 목적이 있습니다.
그런데 모듈에는 클래스와 다른 중요한 몇 가지 차이점이 있습니다.
가장 눈에 띄는 점은 문법입니다.

<br>

## 2.7 더 깊은 토끼 굴로

<br>
