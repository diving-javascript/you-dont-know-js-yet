# 1. 스코프

## 속임수: 런타임 스코프 수정 (Cheating: Runtime Scope Modifications)

프로그램이 컴파일될 때 스코프가 결정되며, 일반적으로 런타임 조건에 의해 영향을 받지 않는다는 것은 이제 명확해졌습니다. 그러나 비엄격 모드에서는 프로그램의 스코프를 런타임 중에 수정할 수 있는 두 가지 방법이 여전히 존재합니다.

이 두 가지 기법은 사용해서는 안 되며, 위험하고 혼란을 초래합니다. 또한, 엄격 모드를 사용하고 있다면 이 두 가지 기법은 허용되지 않습니다. 그러나 프로그램에서 이러한 기법을 마주칠 경우를 대비해 알아두는 것이 중요합니다.

### **1. eval(..) 함수**

`eval(..)` 함수는 프로그램 실행 중에 문자열로 된 코드를 컴파일하고 실행합니다. 만약 그 코드 문자열에 `var` 또는 함수 선언이 포함되어 있다면, 해당 선언은 `eval(..)`이 실행되는 현재 스코프를 수정합니다:

```javascript
function badIdea() {
    eval("var oops = 'Ugh!';");
    console.log(oops);
}
badIdea();   // Ugh!
```

만약 `eval(..)`이 없었다면, `console.log(oops)`에서 `oops` 변수는 존재하지 않아 `ReferenceError`를 발생시켰을 것입니다. 그러나 `eval(..)`은 `badIdea()` 함수의 스코프를 런타임에 수정합니다. 이는 여러 가지 이유로 나쁩니다. 특히, 이미 컴파일되고 최적화된 스코프를 매번 `badIdea()`가 실행될 때마다 수정하므로 성능에 큰 영향을 미칩니다.

### **2. with 키워드**

두 번째 속임수는 `with` 키워드로, 객체를 동적으로 로컬 스코프로 변환합니다. 객체의 속성은 새로운 스코프 블록에서 식별자로 취급됩니다:

```javascript
var badIdea = { oops: "Ugh!" };

with (badIdea) {
    console.log(oops);   // Ugh!
}
```

이 경우 글로벌 스코프는 수정되지 않았지만, `badIdea` 객체는 런타임에 스코프로 변환되어, 그 속성 `oops`는 해당 스코프의 변수로 취급됩니다. 이 역시 성능과 가독성 측면에서 매우 나쁜 아이디어입니다.

### **결론**

`eval(..)` (특히 선언을 생성하는 `eval(..)`)과 `with`는 무조건 피해야 합니다. 이 두 가지 속임수는 엄격 모드에서는 사용할 수 없으므로, 엄격 모드를 사용하면 이러한 유혹에서 벗어날 수 있습니다.

엄격 모드 사용은 안전하고 예측 가능한 코드를 작성하는 데 필수적입니다. 가능하면 항상 엄격 모드를 활성화하여 이러한 잘못된 사용을 방지하십시오.