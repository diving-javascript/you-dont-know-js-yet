# 1. 스코프

## 1.3 코드 컴파일 (Compiling Code)

### **왜 자바스크립트의 컴파일 여부가 중요한가?**

스코프(Scope)는 주로 컴파일 과정에서 결정되므로, 컴파일과 실행이 어떻게 연관되는지 이해하는 것이 스코프를 마스터하는 데 중요합니다.

### **고전적 컴파일러 이론의 세 가지 기본 단계**

프로그램은 고전적 컴파일러 이론에 따라 세 가지 기본 단계를 거칩니다:

1. **토크나이징(Tokenizing)/렉싱(Lexing)**:
    - 문자열을 언어에 의미 있는 조각인 토큰으로 분리합니다.
    - 예를 들어, 프로그램 `var a = 2;`는 다음과 같은 토큰으로 분리됩니다: `var`, `a`, `=`, `2`, `;`.
    - 공백은 의미에 따라 토큰으로 유지될 수도 있고 아닐 수도 있습니다.
    
    (토크나이징과 렉싱의 차이는 미묘하고 학문적입니다. 주로 토큰이 상태 비저장 방식으로 식별되는지 상태 저장 방식으로 식별되는지에 따라 구분됩니다. 간단히 말해, 토크나이저가 상태 저장 파싱 규칙을 사용하여 `a`를 별도의 토큰으로 간주할지 다른 토큰의 일부로 간주할지 결정한다면, 이는 렉싱입니다.)

2. **파싱(Parsing)**:
    - 토큰의 스트림(배열)을 받아 중첩된 요소의 트리로 변환하여 프로그램의 문법 구조를 나타냅니다. 이를 추상 구문 트리(AST)라고 합니다.
    
    예를 들어, `var a = 2;`의 트리는 최상위 노드로 `VariableDeclaration`을 가지며, 자식 노드로 `Identifier`(값은 `a`)와 `AssignmentExpression`을 가집니다. `AssignmentExpression`은 다시 자식 노드로 `NumericLiteral`(값은 `2`)을 가집니다.

3. **코드 생성(Code Generation)**:
    - AST를 실행 가능한 코드로 변환합니다. 이 부분은 언어, 대상 플랫폼 등 여러 요소에 따라 크게 다릅니다.

    자바스크립트 엔진은 `var a = 2;`에 대한 AST를 받아 실제로 변수 `a`를 생성(메모리 할당 등)하고 값을 저장하는 일련의 기계 명령으로 변환합니다.

### **참고 사항**

자바스크립트 엔진의 구현 세부 사항(시스템 메모리 리소스 활용 등)은 여기서 다루는 것보다 훨씬 깊습니다. 우리는 프로그램의 관찰 가능한 동작에 초점을 맞추고, 더 깊은 시스템 수준의 추상화는 자바스크립트 엔진에 맡기겠습니다.

자바스크립트 엔진은 단순히 세 가지 단계로만 이루어지지 않습니다. 파싱 및 코드 생성 과정에서 실행 성능을 최적화하기 위한 단계(즉, 중복 요소를 통합하는 등)가 포함됩니다. 실제로 코드가 실행되는 동안 다시 컴파일되고 재최적화될 수도 있습니다.

### **고성능 자바스크립트 엔진**

자바스크립트 엔진은 다른 언어처럼 사전 빌드 단계에서 컴파일되지 않기 때문에 작업과 최적화를 수행할 시간이 많지 않습니다. 자바스크립트 컴파일은 일반적으로 코드가 실행되기 직전에 아주 짧은 시간(마이크로초 이하) 내에 이루어져야 합니다. 이러한 제약 하에서 최상의 성능을 보장하기 위해, 자바스크립트 엔진은 JIT(Just-In-Time) 컴파일과 같은 다양한 트릭을 사용합니다. JIT는 필요할 때만 컴파일하고 실행 중에 코드가 '핫'해지면 다시 컴파일합니다. 이는 우리의 논의 범위를 넘어서는 내용입니다.