# Chapter6. 스코프 노출 제한

- [Chapter6. 스코프 노출 제한](#chapter6-스코프-노출-제한)
  - [6-1. 최소 노출의 원칙(POLE)](#6-1-최소-노출의-원칙pole)
  - [6-2. 일반(함수)스코프에 숨기기](#6-2-일반함수스코프에-숨기기)
    - [6-2-1 함수 표현식 즉시 호출하기](#6-2-1-함수-표현식-즉시-호출하기)
  - [6-3. 블록으로 스코프 지정](#6-3-블록으로-스코프-지정)
    - [var 과 let](#var-과-let)
  - [6-4. 블록 내 함수 선언](#6-4-블록-내-함수-선언)
  - [6-5. 정리](#6-5-정리)

<br>

## 6-1. 최소 노출의 원칙(POLE)

정보 보안 분야에는 최소 권한의 원칙(POLP-principle of least privilege) 이 존재
이 원칙을 약간 변형한 최소 노출의 원칙(POLE-principle of least exposure)

POLP는 시스템 구성 요소에는 최소한의 권한을 부여하고 접근도 최소화하며 노출 역시 최소화해야 한다는 설계원칙으로 방어적인 아키텍쳐 설계를 대변합니다.
POLP를 기반으로 아키텍쳐를 설계해 각 구성 요소가 필요한 최소한의 기능으로 연결되면, 한 구성 요소의 손상이나 장애가 나머지 시스템에 미치는 영향이 최소화되므로 시스템 전체 보안이 강력해짐

POLP의 변형인 POLE는 조금 더 낮은 수준의 설계에 집중, **노출을 최소화 하고 싶은 항목은 스코프마다 등록된 변수의 노출**

프로그램의 한 부분에서 사용할 변수를 스코프를 통해 다른 스코프에 노출시키면 세 가지 위험한 상황 발생

- 이름출돌
- 예기치 않은 작동
- 의도하지 않은 종속성
  POLE은 변수/함수 스코프 지정 시 기본적으로 필요한 최소한의 것만 노출하고 나머지는 가능한 한 비공개로 유지하도록 제안

모든것을 전역 스코프에 담기보다는 작고 깊게 중첩된 스코프에 변수를 선언하는 것 해결 가능

```
function diff(x,y) {
    if (x > y) {
        let tmp = x;
        x = y;
        y = tmp;
    }

    return y - x;
}

diff(3,7);      // 4
diff(7,5);      // 2
```

let tmp 변수가 적절한 예시이다.
<br>

## 6-2. 일반(함수)스코프에 숨기기

변수나 함수를 숨겨야 하는 상황이 생기면 특이한 이름을 가진 함수를 정의하는 것 보다 함수 표현식을 사용하는 게 더 나은 해결책

```
var factorial = (function hideTheCache() {
    var cache = {};

    function factorial(x) {
        if (x < 2) return 1;
        if (!(x in cache)) {
            cache[x] = x * factorial(x - 1);
        }
        return cache[x];
    }

    return factorial;
})();

factorial(6);
// 720

factorial(7);
// 5040
```

### 6-2-1 함수 표현식 즉시 호출하기

계승 재귀 프로그램에서 놓치기 쉬운 중요한 부분이 있는데, 바로 function 표현식 마지막 줄에 있는 })();입니다.
즉시 호출되는 함수 표현식을 사용했는데 이 패턴은 IIFE(즉시 실행 함수 표현식 immediately invoked function expression) 이름으로 불립니다.
IIFE는 변수나 함수를 숨기는 스코프를 만들고 싶을 때 유용합니다.

<br>

## 6-3. 블록으로 스코프 지정

이제부터는 중첩블록 내에서 let 선언을 사용하는 방법을 고려해봅시다.

블록은 let이나 const같은 블록 스코프 선언을 포함해야 할 필요가 있을 때만 스코프로 작용합니다.

```
{
    // 아직 스코프가 필요하지 않습니다.

    // ..

    // 이제 블록이 스코프여야 한다는 것을 인지 했습니다.
    let thisIsNowAScope = true;

    for (let i = 0; i < 5; i++) {
        // 여기도 스코프인데
        // 이터레이션마다 각각 활성화 됩니다.
        if (i % 2 == 0) {
            // 여기는 스코프가 아닌 블록일 뿐입니다.
            console.log(i);
        }
    }
}
// 0 2 4
```

블록 스코프가 아닌경우

- 객체 리터럴은{}를 사용해 키-캆목록을 구분하지만, 이러한 객체값이 스코프는 아닙니다.
- class는 {}를 사용해 본문을 정의하는 데, 이는 블록이나 스코프가 아닙니다.
- function은 본문을 감쌀 때 {}를 사용하는데, 엄밀히 말해 이는 블록이 아니라 함수 본문을 나타내는 단일 문이므로 블록 스코프를 형성하지 않습니다.
- case 절 주변의 switch 구문에 사용된 {}로는 블록이나 스코프를 정의할 수 없습니다.

블록 스코프를 지원하는 대부분의 프로그래밍 언어에서 명시적으로 블록 스코프를 만드는 건 변수의 범위를 좁히는 일반적인 패턴입니다.
명시적 블록 스코프는 (외부 블록이 스코프인지 여부와 관계없이) 다른 블록 안에서도 유용할 수 있습니다.

```
if (somethingHappened) {
    // 이것은 블록이지만, 스코프는 아닙니다.

    {
        // 이것은 블록이면서 명시적 스코프입니다.
        // explicit scope
        let msg = somethingHappened.message();
        notifyOthers(msg);
    }

    // ..

    recoverFromSomething();
}
```

코드가 짧은 경우에는 어디에 변수를 선언하는지가 그리 중요하지 않을 수 있습니다.
그러나 코드가 길어지면 과도한 노출 문제가 더욱 부각됩니다.

### var 과 let

```
function diff(x,y) {
    if (x > y) {
        var tmp = x;    // `tmp` is function-scoped
        x = y;
        y = tmp;
    }

    return y - x;
}
```

var는 let과 시각적으로 구분되므로 var를 쓰면 '이 변수는 함수 스코프'라는 신호를 명확하게 전달할 수 있기 때문입니다.

<br>

## 6-4. 블록 내 함수 선언

Fib(블록 내 함수 선언)는 변덕스러우니 FiB를 완전히 피해야 실용적으로 코드를 작성할 수 있습니다.
블록 안에서 함수 선언을 절대 하지 마세요. 함수 선언은 함수의 최상위 스코프에서 하세요.
<br>

## 6-5. 정리

변수를 정리하는 데 있어서 가장 중요한 것은 변수를 불필요한 범위에 과도하게 노출되지 않도록 하는것(POLE)입니다.
