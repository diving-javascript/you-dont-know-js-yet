
## 목차

- [6장: 스코프 노출 제한](#6장-스코프-노출-제한)
    - [최소 노출](#최소-노출)
      - [POLP와 POLE](#polp와-pole)
      - [왜 변수를 전역 스코프에 두면 안 되나요?](#왜-변수를-전역-스코프에-두면-안-되나요)
      - [예제: 스코프 노출 최소화](#예제-스코프-노출-최소화)
    - [함수 스코프에서 숨기기](#함수-스코프에서-숨기기)
      - [함수 표현식 사용](#함수-표현식-사용)
    - [함수 표현식을 즉시 호출하기](#함수-표현식을-즉시-호출하기)
    - [스코프와 블록 사용](#스코프와-블록-사용)
      - [예제: 명시적 블록 스코프](#예제-명시적-블록-스코프)
    - [`var`와 `let` 사용](#var와-let-사용)
      - [`var`와 `let`의 예](#var와-let의-예)
      - [`for` 루프에서 `let` 사용](#for-루프에서-let-사용)
    - [주의할 점](#주의할-점)
      - [`catch` 절의 예외](#catch-절의-예외)
    - [블록 내 함수 선언 (FiB)](#블록-내-함수-선언-fib)
      - [FiB 예제](#fib-예제)
    - [결론](#결론)

<br>
<br>

# 6장: 스코프 노출 제한

지금까지 우리는 스코프와 변수가 어떻게 작동하는지에 대해 설명하는 데 집중했습니다. 이제 이러한 기초가 확고히 자리잡았으니, 우리는 프로그램 전반에 걸쳐 적용되는 결정과 패턴에 대해 더 높은 수준의 사고로 주목할 것입니다.

### 최소 노출

함수는 자체 스코프를 정의한다는 점은 이해가 됩니다. 그렇다면 왜 블록도 스코프를 생성해야 할까요?

소프트웨어 공학에서는 일반적으로 소프트웨어 보안에 적용되는 "최소 권한 원칙"(POLP)이라는 기본 규율을 설명합니다. 현재 논의와 관련된 이 원칙의 변형은 일반적으로 "최소 노출"(POLE)이라고 합니다.

#### POLP와 POLE

POLP는 소프트웨어 아키텍처에 대한 방어적 자세를 표현합니다. 시스템의 구성 요소는 최소한의 권한, 최소한의 접근, 최소한의 노출로 작동하도록 설계되어야 합니다. 각 부분이 최소한의 필수 기능으로 연결되면, 하나의 부분이 손상되거나 실패할 경우 전체 시스템에 미치는 영향이 최소화되므로 보안 측면에서 전체 시스템이 더 강력해집니다.

POLP가 시스템 수준의 구성 요소 설계에 초점을 맞춘다면, POLE _노출_ 변형은 더 낮은 수준에 초점을 맞춥니다. 우리는 스코프가 서로 어떻게 상호 작용하는지에 이를 적용할 것입니다.

#### 왜 변수를 전역 스코프에 두면 안 되나요?

프로그램의 모든 변수를 전역 스코프에 배치하지 말아야 하는 이유는 다음과 같습니다:

1. **네이밍 충돌**: 프로그램의 두 다른 부분에서 공통적이고 유용한 변수/함수 이름을 사용하지만, 식별자가 하나의 공유된 스코프(예: 전역 스코프)에서 나온다면, 네이밍 충돌이 발생합니다.

   예를 들어, 모든 루프가 단일 전역 `i` 인덱스 변수를 사용하고, 한 함수의 루프가 다른 함수의 루프의 반복 중에 실행되고, 이제 공유된 `i` 변수가 예상치 못한 값을 가지게 되는 상황을 상상해보세요.

   ```js
   var i;

   function loop1() {
     for (i = 0; i < 5; i++) {
       console.log('loop1:', i);
     }
   }

   function loop2() {
     for (i = 0; i < 5; i++) {
       console.log('loop2:', i);
     }
   }

   loop1();
   loop2();
   ```

   이 코드에서는 두 함수가 동일한 `i` 변수를 공유하여 예상치 못한 값이 출력될 수 있습니다.

2. **예상치 못한 동작**: 사용이 달리 *프라이빗*한 프로그램의 변수/함수를 노출시키면, 다른 개발자가 예상하지 못한 방식으로 이를 사용할 수 있으며, 이는 예상되는 동작을 위반하고 버그를 유발할 수 있습니다.

   예를 들어, 프로그램의 일부가 배열이 모두 숫자라고 가정하지만, 다른 사람의 코드가 배열에 불리언과 문자열을 추가하고 수정하면, 해당 코드는 예상치 못한 방식으로 오작동할 수 있습니다.

   ```js
   var numbers = [1, 2, 3];

   function addNumber(num) {
     numbers.push(num);
   }

   function addBoolean(bool) {
     numbers.push(bool);
   }

   addNumber(4);
   addBoolean(true);

   console.log(numbers); // [1, 2, 3, 4, true]
   ```

   이 코드에서는 `numbers` 배열에 예상치 못한 불리언 값이 추가되어 코드가 예상치 못한 방식으로 동작할 수 있습니다.

3. **의도치 않은 의존성**: 변수를/함수를 불필요하게 노출시키면, 다른 개발자가 이러한 *프라이빗*한 부분을 사용하고 의존하도록 초대합니다.

   예를 들어, 코드가 숫자 배열에 의존하고 나중에 배열 대신 다른 데이터 구조를 사용하는 것이 더 좋다고 판단하면, 이제는 소프트웨어의 영향을 받는 다른 부분을 조정해야 하는 책임을 져야 합니다.

   ```js
   var numbers = [1, 2, 3];

   function getNumbers() {
     return numbers;
   }

   console.log(getNumbers()); // [1, 2, 3]

   // 나중에 배열 대신 세트 사용
   var numbers = new Set([1, 2, 3]);

   console.log(getNumbers()); // [1, 2, 3] -> Set 객체가 출력될 가능성
   ```

   이 코드에서는 `numbers`를 배열에서 세트로 변경하면 `getNumbers` 함수가 예상대로 작동하지 않을 수 있습니다.

변수/함수 스코핑에 적용되는 POLE은 본질적으로 가능한 최소한의 노출을 기본으로 하고, 가능한 모든 것을 프라이빗하게 유지하라고 말합니다. 변수를 가능한 작고 깊이 중첩된 스코프에 선언하고, 모든 것을 전역(또는 외부 함수) 스코프에 배치하지 마십시오.

이렇게 소프트웨어를 설계하면, 이 세 가지 위험을 피하거나 최소화할 수 있는 가능성이 훨씬 더 높아집니다.

#### 예제: 스코프 노출 최소화

```js
function diff(x, y) {
  if (x > y) {
    let tmp = x;
    x = y;
    y = tmp;
  }

  return y - x;
}

diff(3, 7); // 4
diff(7, 5); // 2
```

위 예제에서는 `tmp` 변수를 `if` 블록 내부에 선언하여 스코프를 최소화합니다. 이 예제에서는 `tmp`가 함수 수준에 있거나 전역 변수일 필요가 없습니다. 따라서 `if` 블록 내부에 `let`을 사용하여 블록 스코핑합니다.

### 함수 스코프에서 숨기기

변수와 함수 선언을 가능한 낮은(가장 깊이 중첩된) 스코프에 숨기는 것이 왜 중요한지 이제 명확해졌습니다. 그렇다면 어떻게 그렇게 할 수 있을까요?

#### 함수 표현식 사용

함수 스코프를 사용하여 변수를 숨길 수 있습니다. 이를 위해 함수 표현식을 사용할 수 있습니다.

```js
var factorial = (function hideTheCache() {
  var cache = {};

  function factorial(x) {
    if (x < 2) return 1;
    if (!(x in cache)) {
      cache[x] = x * factorial(x - 1);
    }
    return cache[x];
  }

  return factorial;
})();

factorial(6); // 720
factorial(7); // 5040
```

위 예제에서 `cache` 변수를 함수 스코프 내에 숨기기 위해 함수 표현식을 사용했습니다. `cache`는 `factorial` 함수 외부에서는 접근할 수 없습니다. 이를 통해 `cache` 변수가 외부에 노출되지 않도록 합니다.

### 함수 표현식을 즉시 호출하기

즉시 호출 함수 표현식(IIFE)은 변수를/함수를 숨기기 위해 스코프를 생성할 때 유용합니다.

```js
(function () {
  // 내부 숨겨진 스코프
})();
```

IIFE는 표현식이기 때문에 JS 프로그램에서 표현식이 허용되는 **어떤** 장소에서도 사용할 수 있습니다. 이를 통해 변수를 숨기기 위한 임시 스코프를 생성할 수 있습니다.

### 스코프와 블록 사용

블록 스코핑은 변수/함수 선언의 노출을 제한하는 데 유용합니다.

```js
{
  let thisIsNowAScope = true;

  for (let i = 0; i < 5; i++) {
    if (i % 2 == 0) {
      console.log(i); // 0, 2, 4
    }
  }
}
```

위 예제에서는 블록 스코핑을 통해 변수의 노출을 최소화합니다. 블록 스코핑을 통해 변수의 범위를 필요한 곳으로만 제한할 수 있습니다.

#### 예제: 명시적 블록 스코프

```js
if (somethingHappened) {
  {
    let msg = somethingHappened.message();
    notifyOthers(msg);
  }

  recoverFromSomething();
}
```

위 예제에서는 명시적 블록 스코프를 사용하여 `msg` 변수의 노출을 최소화합니다. `msg`는 `if` 블록 내부에서만 필요하므로, 해당 블록 내에 블록 스코핑합니다.

### `var`와 `let` 사용

`var`와 `let`의 차이를 이해하고 적절히 사용하는 것이 중요합니다.

#### `var`와 `let`의 예

```js
function diff(x, y) {
  if (x > y) {
    var tmp = x; // `tmp`는 함수 스코프에 속합니다
    x = y;

    y = tmp;
  }

  return y - x;
}
```

위 예제에서는 `var`를 사용하여 함수 스코프에 변수를 선언했습니다. 이는 `tmp` 변수가 함수 전체에서 접근 가능하게 합니다.

#### `for` 루프에서 `let` 사용

```js
for (let i = 0; i < 5; i++) {
  // 무언가를 합니다
}
```

위 예제에서는 `for` 루프의 반복자 변수를 `let`으로 선언하여 블록 스코핑을 사용했습니다. 이는 `i` 변수가 루프 내부에서만 접근 가능하게 합니다.

### 주의할 점

#### `catch` 절의 예외

`catch` 절은 추가적인 블록 스코핑 선언 기능을 사용합니다.

```js
try {
  doesntExist();
} catch (err) {
  console.log(err);
  let onlyHere = true;
  var outerVariable = true;
}

console.log(outerVariable); // true
```

위 예제에서는 `catch` 절의 `err` 변수가 블록 스코핑되어 블록 내부에서만 접근 가능합니다.

### 블록 내 함수 선언 (FiB)

블록 내부에 함수 선언을 배치하는 것은 예측 가능하지 않은 결과를 초래할 수 있습니다.

#### FiB 예제

```js
if (false) {
  function ask() {
    console.log('이게 실행되나요?');
  }
}
ask();
```

위 예제는 다양한 JS 환경에서 다르게 동작할 수 있습니다. 이는 블록 내 함수 선언이 예측 불가능한 동작을 초래할 수 있음을 보여줍니다.

### 결론

렉시컬 스코핑 규칙은 프로그램의 변수를 적절히 구성하는 데 중요합니다. POLE 원칙을 따르면 불필요한 스코프 노출을 최소화할 수 있습니다. 블록 스코핑과 함수 표현식을 사용하여 변수의 노출을 최소화하는 습관을 기르면, 프로그램의 안정성과 유지보수성이 향상됩니다.
