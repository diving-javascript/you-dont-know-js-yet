# Chapter5. 변수의 비밀 생명주기

- [Chapter5. 변수의 비밀 생명주기](#chapter5-변수의-비밀-생명주기)
  - [5-1. 변수 사용 가능 시점](#5-1-변수-사용-가능-시점)
    - [5.1.1 선언문과 표현식에서의 호이스팅 차이](#511-선언문과-표현식에서의-호이스팅-차이)
  - [5-2. 호이스팅 비유일 뿐입니다](#5-2-호이스팅-비유일-뿐입니다)
  - [5-3. 중복 선언 처리하기](#5-3-중복-선언-처리하기)
    - [5.3.1 const 재선언](#531-const-재선언)
    - [5.3.2 반복문](#532-반복문)
  - [5-4. 초기화되지 않은 변수와 TDZ](#5-4-초기화되지-않은-변수와-tdz)
  - [5-5. 정리](#5-5-정리)

<br>

## 5-1. 변수 사용 가능 시점

```
greeting();
// Hello!

function greeting() {
    console.log("Hello!");
}

```

1장에서 모든 식별자는 컴파일 타임때 각자의 스코프에 등록된다는 걸 배웠습니다.
그리고 모든 식별자는 자신이 속한 스코프가 생성될 때 해당 스코프의 시작 부분에서 생성된다는 것 역시 배웠습니다.

이렇게 선언은 스코프 아래에 있더라도 스코프 시작 부분에서 변수의 가시성이 확보되는 걸 호이스팅이라고 합니다.

스코프 내 코드가 실행되기 시작하는 순간, 변수 greeting에 어떻게 값이 할당된 걸까요 ??
그 이유는 함수 선언문의 고유한 특성인 함수 호이스팅 때문입니다.
함수 선언문으로 함수를 선언하면 함수 이름에 해당하는 식별자가 스코프 최상단에 등록되고 함수 참조로 그 값이 자동 초기화 됩니다.

### 5.1.1 선언문과 표현식에서의 호이스팅 차이

함수 호이스팅은 일반적인 함수선언문에만 적용되고, 함수 표현식에는 적용되지 않습니다.

```
greeting();
// TypeError

var greeting = function greeting() {
    console.log("Hello!");
};

```

TypeError는 허용되지 않은 값을 가지고 무언가를 하려고 할 때 발생하는 오류입니다.
에러가 ReferenceError가 아니라는 점이 이상한 점입니다.
스코프내 greeting이라는 식별자를 찾지 못했다는 걸 나타내기 위해 ReferenceError가 발생했어야 하는데 그렇지 않고 JS엔진은 greeting은 찾았지만 그 순간에 greeting에 함수 참조가 없다고 이야기 합니다.

var 선언한 변수는 호이스팅이 되고 여기에 더해 스코프가 시작될 때 undefined로 자동 초기화 됩니다.
이런이유 때문에 네 번째 줄이 함수 참조 할당이 실행되기 전까지, 첫번째 줄에 있는 greeting은 기본값인 undefined로 남아있는 겁니다.

선언문과 표현식에서 주의해야 할 차이점을 정리하면 다음과 같습니다.
함수 선언문은 호이스팅되고 해당 함숫값으로 됩니다.
반면 var로 선언한 변수는 호이스팅 되기 하지만 undefined로 초기화됩니다. 그리고 함수 표현식에서 실제 할당은 런타임에 코드가 실행되기 전까지 일어나지 않습니다.

선언문과 표현식 모두 이름 식별자는 호이스팅된다는 공통점 존재
<br>

## 5-2. 호이스팅 비유일 뿐입니다

프로그램의 모든 스코프 경계와 선언문을 정확히 찾을 수 있는 유일한 방법은 코드를 파싱하는 것뿐입니다.
파싱 없이 프래그램을 실행할 방법은 그 어디에도 없습니다.

<br>

## 5-3. 중복 선언 처리하기

```
var studentName = "보라";
console.log(studentName);
// 보라

var studentName;
console.log(studentName);   // ???
```

```
var studentName;
var studentName;    // 아무 의미 없는 작업입니다.

studentName = "Frank";
console.log(studentName);
// Frank

console.log(studentName);
// Frank
```

동일한 스코프에서 변수가 두 번 이상 선언되면 재선언되지 않습니다.
호이스팅은 스코프의 시작 부분에 변수를 등록하는 방식이므로 두 번째 줄(스코프 중간부분)에 있는 var studentName;은 아무런 역활을 하지 못합니다.

중복 변수 선언에 관한 예시에서 대부분의 사람들이 var studentName;이 var studentName =undefined과 같다고 생각하는데 그렇지 않다는 점도 짚고 넘어가야 할 점입니다.

```
var greeting;

function greeting() {
    console.log("안녕하세요!");
}

// basically, a no-op
var greeting;

typeof greeting;        // "function"

var greeting = "안녕하세요!";

typeof greeting;        // "string"
```

첫줄 greeting은 undefined로 자동 초기화
함수선언 greeting은 다시 스코프에 등록하지는 않지만 함수 호이스팅이 일어나고, 함수 호이스팅은 변수 호이스팅보다 순위가 높기 때문에 greeting을 함수 참조로 초기화시킵니다.
두 번째 greeting은 아무 작업도 수행하지 않음
마지막 var greeting은 문자열을 할당하고 var은 아무도 역활도 하지 않습니다.

```
let studentName = "Frank";

console.log(studentName);

let studentName = "Suzy";
```

let 이나 const를 사용한 '재선언은 명시적으로 허용되지 않습니다.'

### 5.3.1 const 재선언

const는 let 보다 제약 조건이 더 많습니다.
let은 문체상 이유로 '재선언'을 허용하지 않지만, const가 '재선언'을 허용하지 않는 데에는 기술적 이유가 있습니다.
const로 선언된 변수를 다시 선언하는 것은 해당 변수를 재할당하는 것과 같습니다.
그런데 const 선언은 재할당 할 수 없으며 항상 할당이 필요합니다.
따라서 이런 기술적인 이유로 const를 사용한 재선언은 허용되지 않습니다.

### 5.3.2 반복문

JS에서는 동일한 스코프 내에서 변수를 다시 선언하는 것을 추천하지 않는 다점을 분명히 했습니다.<br>

## 5-4. 초기화되지 않은 변수와 TDZ

```
// ..

let studentName;
// or:
// let studentName = undefined;

// ..

studentName = "Suzy";

console.log(studentName);
// Suzy
```

컴파일러는 프로그램 중간 studentName이 선언된 지점에서 해당 선언을 자동으로 초기화하는 명령도 내립니다.
그렇기 때문에 우리는 이 초기화가 발생하기 전까지는 변수를 사용할 수 없습니다. const로 선언한 변수도 예외는 없습니다.

스코프에 진입한 후, 변수 자동 초기화가 일어나기까지의 시간을 지칭하기 위해 TC 39 위원회는 TDZ라는 새로운 용어를 만들었습니다.
TDZ란 변수는 존재하지만 초기화되지 않아 어떤 방식으로도 해당 변수에 접근할 수 없는 시간대를 의미합니다.
변수의 초기화는 컴파일러가 원래 선언 지점에 남긴 명령을 실행할 때만 발생합니다.

TDZ의 오류를 피하기 위해서는 'let과 const 선언은 스코프 맨위에 둬라'
<br>

## 5-5. 정리
