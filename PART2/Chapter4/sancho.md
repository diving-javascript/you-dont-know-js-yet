# Chapter4. 전역 스코프

- [Chapter4. 전역 스코프](#chapter4-전역-스코프)
  - [4-1. 구슬과 양동이](#2-1-구슬과-양동이)
  - [2-2. JS엔진 구성원 간의 대화](#2-2-js엔진-구성원-간의-대화)
  - [2-3. 중첩 스코프](#2-3-중첩-스코프)
    - [2-3-1. 탐색이 실패할 경우](#2-3-1-탐색이-실패할-경우)
    - [2-3-2. 스코프 건물](#2-3-2-스코프-건물)

<br>

## 4-1. 전역 스코프를 배워야 하는 이유

JS 파일 여러 개가 모여 애플리케이션이 만들어진다는 사실은 여러분 익히 알고 계실거다
그렇다면 JS엔진은 분리된 여러 개의 파일을 실행 시점에 어떻게 하나로 연결 시킬까요 ??

브라우저에서 실행되는 애플리케이션은 주로 3가지 방법을 사용해 파일을 하나로 모으고 실행합니다.

1. (별로의 모듈 번들러를 사용하지않고)ES 모듈을 바로 사용하는 경웨 파일을 각자 하나씩 로딩합니다.
   로딩 후에는 import 문에 있는 다른 모듈을 참조합니다.

2. 구축 과정에 번들러가 관여하는 경우에는 파일 전체가 합쳐져서 브라우저와 JS엔진에 전달됩니다.
   따라서 브라우저, JS엔진은 하나의 커다란 파일만 처리합니다. 애플리케이션 하나가 단일 파일에 모여있는 경우라도 파일 내 코드 조각 일부에서 다른 코드 조각을 참조할 때 사용할 이름을 등록한다든가 타 코드 조각에 접근할 때 적용할 메커니즘이 필요합

번들러는 다양한 빌드 환경을 설정할 수 있도록 하는데, 그 중 일부는 파일 내용 전체를 래퍼함수나 유니버셜 모듈 등을 사용해 하나의 스코프 안에 묶도록 해줍니다. 이때 각 코드 조각은 다음 예시처럼 다른 코드 조각에서 자신을 접근할 수 있도록 하는 지역 변수를 공유 스코프 안에 스스로 등록합니다.

```
(function wrappingOuterScope(){
    var moduleOne = (function one(){
        // ..
    })();

    var moduleTwo = (function two(){
        // ..

        function callModuleOne() {
            moduleOne.someMethod();
        }

        // ..
    })();
})();
```

wrappingOuterScope tmzhvmsms는 전역 스코프가 아닌 함수 스코프이긴 하지만 애플리케이션 전체를 아우르는 스코프처럼 작동

3. 전역 스코프를 활용하는 방법
   모든 코드 조각을 아우르는 하나의 스코프가 없는 경우라면 코드 조각들이 협업할 수 있는 유일한 방법은 **전역 스코프**를 통해서 뿐입니다.

```
var moduleOne = (function one(){
    // ..
})();
var moduleTwo = (function two(){
    // ..

    function callModuleOne() {
        moduleOne.someMethod();
    }

    // ..
})();
```

전역 스코프는 런타임에 프로그램을 구성하는 코드 조각들이 어디에 있는, 그리고 각 코드 조각이 어떤 방식으로 다른 코드 조각에 접그냏 협력하는지에 관여하는 것뿐만 아니라 다음의 경우에도 사용합니다.

- JS 내장 기능을 사용할 때
  - 원싯값
  - 네이티브 객체
  - 전역 함수
  - 네임스페이스
  - JS와 협력 관계인 기술
- 특정 호스팅 환경에서 제공하는 내장 기능을 사용할 때
  - console과 연관 메서드
  - DOM(window,document)
  - 타이머
  - 웹API

변수 전체를 전역 스코프에 선언하느 건 버그가 발생하길 기도하는 것과 다름없습니다.
하지만 모든 JS프로그램이 전역 스코프를 '접착제'삼아 파일을 모으고 실행한다는 사실은 부인할 수 없습니다.

<br>

## 4-2. 전역 스코프의 위치

전역 스코프는 함수나 블록 안이 아닌 파일 가장 바깥쪽에 위치한다고 생각할 수 있는데, 실상은 그리 간단하지 않습니다.

### 4.2.1 브라우저의 창 window 객체

전역 스코프가 처리되는 환경 중 가장 순수한 환경은 브라우저에서 단독으로 .js파일을 로드할 때 관찰할 수 있습니다. ??? 이해가 잘 안된다 ??

#### 전역을 가리는 전역

섀도잉과 전역 언섀도잉을 다시 떠올려봅시다.
안쪽 스코프에 선언된 변수는 바깥쪽 스코프에 선언된 이름이 같은 변수를 가리고 접근을 막습니다.

그런데 전역 변수와 이름 같은 전역 프로퍼티는 섀도잉과 다른방식으로 작동합니다.

```
window.something = 42;

let something = "Kyle";

console.log(something);
// Kyle

console.log(window.something);
// 42
```

전역 객체에 있는 프로퍼티와 전역 스코프에 등록된 식별자가 다르게 작동하도록 코드를 작성하는건 좋지 않습니다.

#### DOM 전역 변수

브라우저는 사실 완전히 순수한 환경은 아닙니다.
브라우저에 돌아가는 JS 프로그램을 다뤄보면 알 수 있겠지만,DOM 요소에 id속성을 추가하면 전역 변수가 자동으로 생기고, 이 변수를 통해 해당 DOM 요소에 접근 할 수 있습니다.

```
<ul id="my-todo-list">
   <li id="first">Write a book</li>
   ..
</ul>

first;
// <li id="first">..</li>

window["my-todo-list"];
// <ul id="my-todo-list">..</ul>
```

id 속성이 있는 DOM요소에 대응하는 변수를 자동으로 전역에 등록하는 것은 브라우저 환경에서 오래전부터 지원하던 기능입니다. 레거시를 개선할 수 있지만 여전히 지원하는 이유는 만들어진 지 오래된 사이트 중 자동 변수 등록에 의존하는 경우가 많기 때문입니다.

#### window.name 정체

```
var name = 42;

console.log(name, typeof name);
// "42" string
```

window.name은 브라우저가 전역에 미리 정의해놓은 전역 객체의 프로퍼티인데, 언뜻 보면 이 프로퍼티는 전역 변수처럼 작동한다고 생각할 수 있습니다. 하지만 '일반'전역 변수와는 다르게 작동합니다.

예시처럼 var를 사용해서 전역에 변수를 선언하면 이미 선언되어 있는 전역 객체 프로퍼티 name을 가리지는 않습니다. 전역 스코프에 name이라는 이름을 가진 프로퍼티가 있기 때문에 그냥 var 선언이 무시되고 숫자 42는 window.name의 값이 됩니다.
참고로 let name으로 변수를 선언했다면 별도의 전역 변수가 name이 생기면서 window.name이 가려졌을 겁니다.

분명 name에 숫자 42를 할당했음에도 값을 읽으면 문자열 '42'가 나오는 이유는 name 프로퍼티는 window 객체에 사전에 정의된 getter이자 setter이기 때문입니다. 그리고 setter에는 어떤 값을 넣든 문자열로 변환시킨다는 규칙이 있고요.

### 4.2.2 웹 워커

웹 워커는 브라우저에서 돌아가는 JS의 작동방식을 바꿔주는 웹 플랫폼 확장 기능으로 JS파일을 JS프로그램이 돌아가고 있는 스레드가 아닌(운영체제가 알아서 만드는)별도의 스레드에서 돌아갈 수 있게 해줍니다.

웹 워커를 사용하는 프로그램은 별도의 스레드에서 실행되기 때문에 레이스 컨디션이나 기타 경쟁상태를 막거나 피하려는 목적으로 메인 애플리케이션 스레드와 통신이 제한됩니다.

웹 워커는 완전히 별개의 프로그램으로 취급되므로 메인 JS 프로그램과 전역 스코프를 공유하지 않습니다.
하지만 코드를 실행하는 건 브라우저의 JS엔진이기 때문에 '웹 워커에도 순수 전역 스코프 메커니즘이 적용되지 않을 까' 라는 기대를 해볼 수 있습니다. 그런데 웹 워커에서는 DOM에 접근할 수 없으므로 전역 스코프에 접근할 수 있게 하는 window는 사용하지 못합니다.

### 4.2.3 개발자 도구와 콘솔,REPL

개발자 도구는 JS 코드를 처리하긴 하지만 DX라 부르는 개발자 경험을 향상하기 위해 UX가 설계되었습니다.
DX를 중시하며 일반 JS프로그램을 처리할 때 보다 덜 엄격하게 JS코드 조각을 처리하다보면 눈에 띄는 차이가 생길 수 있습니다. 일반 JS프로그램이었다면 오류가 났을 코드인데 개발자 도구에 입력했을 때는 오류가 나지 않는 식으로 말이죠.

이러한 차이중 스코프와 연관된 사례는 다음과 같습니다.

- 전역 스코프의 작동방식
- 호이스팅
- 가장 바깥 스코프에서 (let과 const로) 블록 스코프 선언을 할 때

콘솔과 REPL을 사용해 가장 바깥 스코프에 문을 입력했을 때, 해당 문이 실제 전역 스코프에서 처리되는 것처럼 보일 수 있지만 실제로 그렇지 않습니다. 콘솔,REPL은 전역 스코프 작동방식을 유사하게 모방하여 입력 받은 문을 처리합니다. 그런데 이들은 에뮬레이터일 뿐이라서 JS엔진에서 전역 스코프가 작동하는 방식을 완벽하게 모방하지는 못합니다.

개발자 도구는 실제 JS프로그램 컨텍스트를 결정 혹은 검증하려는 목적으로 쓰기에는 JS미묘한 동작을 재현할 수 없어 적합하지 않다는 점을 알아두길 바랍니다.

#### 4.2.4 ES 모듈

모듈 패턴은 ES6에서 공식 지원하기 시작했습니다. ES모듈의 두드러지는 특징은 파일 내 최상위 레벨 스코프 작동 방식입니다.

```
var studentName = "Kyle";

function hello() {
    console.log(`Hello, ${ studentName }!`);
}

hello();
// Hello, Kyle!

export hello;
```

studentName과 hello는 모듈 내에서는 최상위 레벨인 가장 바깥 스코프에서 선언되었지만 전역 변수가 되지 않습니다. 대신 모듈 범위 스코프 변수가 됩니다. 그런데 모듈에서는 최상위 레벨의 선언을 프로퍼티로 추가할 수 있는 모듈 범위 스코프 객체를 지원하지 않습니다.
그렇다고해서 모듈로 구성된 프로그램에 전역 변수가 없다거나 전역 변수에 접근 할 수 없다는 뜻은 아닙니다.
다만 모듈 내 최상위 레벨에서 변수를 선언하면 전역 변수가 생성되지 않는다는 의미입니다.

모듈 최상위 레벨 스코프에서는 모듈 내 모든 콘텐츠가 함수에 래핑된 것처럼 묶여서 처리되고,이 묶음은 전역 스코프의 하위 스코프가 됩니다. 따라서 전역 스코프내 변수는 모듈 스코프 내에서 렉시컬 식별자를 통해 접근 가능합니다.

ES 모듈 패턴에서는 현재 모듈을 작동시키는 데 필요한 모든 모듈을 임포트하는 전역 스코프에 대한 의존도를 최소화하라고 권장합니다.
따라서 ES 모듈 패턴을 사용하면 전역 스코프나 전역 스코프 객체를 사용하는 빈도가 줄어들 수 밖에 없습니다.

#### 4.2.5 Node.js

Node.js에는 개발자를 당황하게 만드는 몇 가지 특징이 있습니다.
엔트리 파일을 포함해 모든 JS파일을 모듈로 처리한다는 특징이 그중 하나입니다.
이런 특징은 브라우저에서 모듈이 아닌 파일을 로드할 때와 다르게 각 JS파일이 자체 스코프를 갖도록 합니다.

Node.js에서 진짜 전역 변수는 어떻게 정의할까요 ?? Node.js 내장 전역 프로퍼티인 global에 프로퍼티를 추가하는 방법이 유일합니다. global은 진짜 전역 스코프 객체에 접근 할 수 있게 해주는 참좃값으로, 브라우저 환경의 window와 유사합니다.
<br>

## 4-3. globalThis

여러 JS 호스팅 환경을 살펴봤는데, 호스팅 환경마다 차이를 보이는 특징을 처리하면 다음과 같습니다.

- 최상위 레벨 스코프에 var,function 또는 let,const,class를 사용해 전역 변수를 선언할 수 있는데 두 방식에는 차이가 있습니다.
- var 또는 function을 사용해 선언하는 경우 해당 선언은 전역 객체의 프로퍼티로 추가됩니다.
- 전역 스코프 객체(전역 변수를 추가하거나 검색할 때 프로퍼티로 사용)는 window,self,global로 참조합니다.

전역 스코프 접근과 작동방식은 대부분의 개발자가 생각하는 것 보다 훨씬 복잡합니다.
<br>

## 4-4. 정리

여러분이 작성한 코드가 브라우저를 넘어 점차 그 영역을 확대해 감에 따라 호스트 환경별로 전역 스코프와 전역 스코프 객체가 어떤 차이를 보이는지 확실히 아는 것이 중요해졌습니다.
