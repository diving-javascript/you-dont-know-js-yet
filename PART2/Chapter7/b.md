## 7장

이번 장에서는 자바스크립트의 핵심 개념 중 하나인 **클로저**에 대해 자세히 알아보았습니다. 클로저는 코드의 효율성과 유지보수성을 향상시키는 데 중요한 역할을 합니다. 이 요약 정리에서는 예제와 함께 클로저의 개념과 동작 방식, 장점, 수명 주기, 관리 방법, 그리고 이해를 위한 모델까지 자세하게 살펴봅니다.

### 클로저란 무엇일까요?

클로저는 **함수**와 밀접한 관련이 있습니다. 함수가 렉시컬 스코프 외부에서 실행되더라도 자신이 선언되었던 스코프의 변수에 접근할 수 있는 능력을 의미합니다. 

**예시**

```javascript
function outerFunction() {
  var outerVar = "외부 변수";

  function innerFunction() {
    console.log(outerVar); // 외부 변수에 접근
  }

  return innerFunction;
}

var myFunction = outerFunction();
myFunction(); // 출력: "외부 변수"
```

위 예제에서 `innerFunction`은 `outerFunction` 내부에서 선언된 함수입니다. `innerFunction`은 `outerVar`라는 외부 스코프의 변수에 접근하고 있습니다. `outerFunction`의 실행이 끝나면 일반적으로 `outerVar`는 더 이상 접근할 수 없게 되지만, `innerFunction`을 반환하고 나중에 호출하면 `outerVar`에 여전히 접근할 수 있습니다. 이것이 바로 클로저 덕분입니다.

### 클로저는 어떻게 동작하나요?

함수가 생성될 때, 자바스크립트 엔진은 해당 함수가 선언된 위치를 기억하고 주변 스코프의 변수에 대한 참조를 유지합니다. 이러한 참조를 통해 함수는 나중에 호출되더라도 원래 스코프의 변수에 접근할 수 있습니다.

**예시**

```javascript
function makeCounter() {
  var count = 0;

  return function() {
    count++;
    return count;
  };
}

var counter1 = makeCounter();
var counter2 = makeCounter();

console.log(counter1()); // 출력: 1
console.log(counter1()); // 출력: 2
console.log(counter2()); // 출력: 1
```

`makeCounter` 함수는 호출될 때마다 새로운 카운터 함수를 생성합니다. 각 카운터 함수는 자신만의 `count` 변수를 가지고 있으며, 클로저 덕분에 이전 값을 기억하고 증가시킬 수 있습니다.

### 클로저는 언제 관찰할 수 있을까요?

클로저는 함수가 스코프 체인의 다른 분기, 즉 자신이 선언된 스코프가 아닌 다른 스코프에서 호출될 때만 관찰 가능합니다. 

**예시**

```javascript
function outerFunction() {
  var outerVar = "외부 변수";

  function innerFunction() {
    console.log(outerVar);
  }

  innerFunction(); // 클로저가 아님
}

outerFunction();
```

위 예제에서 `innerFunction`은 `outerFunction` 내부에서 호출되기 때문에 클로저를 사용하는 것처럼 보이지 않습니다. 이 경우 단순히 렉시컬 스코프 규칙을 따르는 것입니다.

### 클로저는 왜 유용할까요?

클로저는 다음과 같은 장점을 제공합니다.

* **효율성 향상**: 함수 인스턴스 내부에 필요한 정보를 저장하여 반복적인 계산을 피할 수 있습니다.
* **코드 가독성 향상**: 변수의 스코프를 제한하여 코드를 더 깔끔하게 구성하고 이해하기 쉽게 만들 수 있습니다.

### 클로저의 수명 주기는 어떻게 될까요?

클로저는 함수에 대한 참조가 있는 한 변수를 계속 기억합니다. 마지막 함수 참조가 사라지면 GC(가비지 컬렉션)에 의해 메모리에서 해제됩니다.

### 클로저를 어떻게 관리해야 할까요?

클로저가 어떤 변수를 참조하고 있는지 주의 깊게 살펴보고, 더 이상 필요하지 않은 참조는 명시적으로 해제하는 것이 좋습니다. 이렇게 하면 불필요한 메모리 사용을 방지할 수 있습니다.

### 클로저를 이해하는 두 가지 모델

클로저를 이해하는 데 도움이 되는 두 가지 모델이 있습니다.

* **관찰적 모델**: 함수가 다른 스코프로 이동해도 마치 원래 스코프의 변수를 기억하는 것처럼 보이는 관점입니다.
* **구현적 모델**: 함수 인스턴스는 원래 스코프에 그대로 유지되고, 다른 스코프로 전달되는 것은 함수에 대한 참조라는 관점입니다.

두 모델 모두 클로저를 이해하는 데 유용하며 어떤 모델을 선택하든 프로그램의 동작 방식은 동일합니다.

### 클로저는 어디에 활용될까요?

클로저는 다양한 상황에서 유용하게 활용될 수 있습니다.

* **콜백 함수**: 이벤트 핸들러나 Ajax 요청 콜백에서 클로저를 사용하여 주변 스코프의 정보에 접근할 수 있습니다.
* **부분 적용 및 커링**: 함수의 일부 입력을 미리 제공하고 나머지 입력은 나중에 제공하여 함수의 형태를 변경할 수 있습니다.
* **정보 은닉**: 클로저를 사용하여 변수와 함수를 외부 스코프로부터 숨기고, 필요한 부분만 공개 인터페이스로 노출할 수 있습니다.

### 마무리

클로저는 자바스크립트의 강력한 기능 중 하나이며, 다양한 방식으로 활용하여 코드의 효율성, 구성 및 가독성을 향상시킬 수 있습니다. 

다음 장에서는 클로저를 활용한 모듈 패턴에 대해 알아보겠습니다.
